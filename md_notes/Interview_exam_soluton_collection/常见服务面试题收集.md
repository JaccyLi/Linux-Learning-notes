#   一.  FTP/TFTP/NFS

> 1.***FTP的传输模式*：ASCII传输模式和二进制传输模式。**

**ASCII传输模式**： 假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件（尽管字处理文件包含的大部分是文本，其中也包含有指示页尺寸，字库等信息的非打印符）。在拷贝任何非文本文件之前，用binary 命令告诉ftp逐字拷贝，不要对这些文件进行处理，这也是下面要讲的二进制传输。 

**二进制传输模式**： 在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。 如果两台通讯的机器为同一类型，则可优先使用二进制拷贝。



> 2.**FTP的工作方式： Standard (也就是 PORT方式，主动方式)和 Passive (也就是PASV，被动方式)** 

**主动方式**： Port模式FTP 客户端首先和FTP服务器的TCP  21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。  PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP  server必须和客户端建立一个新的连接用来传送数据。 

**被动方式**： Passive模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接 

**请注意**: PORT模式建立数据传输通道是由服务器端发起的，服务器使用20端口连接客户端的某一个大于1024的端口；在PASV模式中，数据传输的通道的建立是由FTP客户端发起的，他使用一个大于1024的端口连接服务器的1024以上的某一个端口。  在FTP客户连接服务器的整个过程中，控制信道是一直保持连接的，而数据传输通道是临时建立的。  



> 3.**TFTP工作原理**

**建立连接**：默认情况下，作为 TFTP 服务器的主机 A 会监听 69 端口，当作为客户端的主机 B 想要下载或上传文件时，会向主机 A 的 69 端口发送包含读文件（下载）请求或写文件（上传）请求的数据包。主机 A 收到读写请求后，会打开另外一个随机的端口，通过这个端口向主机 B 发送确认包、数据包或者错误包。

**下载**：客户端向服务器的 69 端口（通常情况下）发送一个读请求，服务器收到这个读请求以后，会打开另外一个随机的端口（假设端口号是 59509），然后在它默认的路径下寻找这个文件，找到这个文件以后，每次读入文件的 512 个字节，通过端口 59509 将这 512 个字节放入数据包中发送给客户端，数据包中还包含了操作码和数据块的编号，块编号从 1 开始计数；客户端收到数据包以后，会向服务器的 59509 端口发送一个确认包，里面包含了它收到的数据包的块编号；服务器收到确认包以后，继续发送文件的下一个 512 个字节。如此循环往复，直到文件的末尾，最后一个数据包的数据块的大小会小于 512 个字节，这时服务器就认为传输已经结束，等他接收到这最后一个数据包的确认包之后就会主动关闭连接。而客户端收到这个小于 512 个字节的数据包后也认为传输已经结束，发送完确认包之后也会关闭连接。也许会有一种极端情况，就是文件的大小正好是 512 字节的倍数，这样的话，最后一个数据包的大小也是 512 个字节，这时服务器发送完包含文件数据的数据包以后，还会额外发送一个包含 0 字节的数据包，作为最后一个数据包，这样就可以保证客户端收到的最后一个数据包的大小总是小于 512 个字节的。也就是说，对于客户端而言，只要它收到的数据包的大小小于 512 个字节，它就认为传输已经结束，它就会关闭连接。

**上传**：客户端向服务器的 69 端口（通常情况下）发送一个写请求，服务器收到这个写请求以后，会打开另外一个随机的端口（假设端口号是 59509），向客户端发送一个确认包，其中块编号是 0，以此来告诉客户端自己已经准备好接收文件，并且告诉客户端自己接收文件的端口号。然后客户端就开始向服务器的 59509 端口发送数据包，服务器收到数据包后向客户端发送确认包，直到整个文件发送完毕。这个过程和下载是一样的，只不过双方的角色互换了，客户端成了发数据的一方，而服务器是接收数据的一方。



> 4.**NFS工作原理**

![image-20200406105340809](F:\M39-Slides-Edited-notes\md_notes\Interview_exam_soluton_collection\png\image-20200406105340809.png)



# 二. rsync

一般企业在使用 rsync 时会配合 inotify 使用，使用 inotify 监听文件修改情况，一旦文件某些 属性改变，就通知 rsync 进行备份 

- **inotify + rsync** 方式实现数据同步
- sersync ：金山公司周洋在 inotify 软件基础上进行开发的，功能更加强大

- 工作原理：

  要利用监控服务（inotify），监控同步数据服务器目录中信息的变化

  发现目录中数据产生变化，就利用 rsync 服务推送到备份服务器上

- **inotify**：

  异步的文件系统事件监控机制，利用事件驱动机制，而无须通过诸如 cron 等的轮询机制来获取事件，

  linux 内核从 2.6.13 起支持 inotify，通过 inotify 可以监控文件系统中添加、删除，修改、移动等各种事件

```bash
max_queued_events：inotify事件队列最大长度，如值太小会出现 Event Queue Overflow  误，默认值：16384 max_user_instances：每个用户创建inotify实例最大值，默认值：128 max_user_watches：可以监视的文件数量（单进程），默认值：8192
```

```
[root@centos8 ~]#vim /etc/sysctl.conf
fs.inotify.max_queued_events=66666
fs.inotify.max_user_watches=100000  
[root@centos8 ~]#sysctl  -p
fs.inotify.max_queued_events = 66666
fs.inotify.max_user_watches = 100000
[root@centos8 ~]#cat /proc/sys/fs/inotify/*
66666
128
100000
```

**inotify-tools** 包： 

- **inotifywait**： 在被监控的文件或目录上等待特定文件系统事件（open ，close，delete 等） 发生，常用于实时同步的目录监控
- **inotifywatch**：收集被监控的文件系统使用的统计数据，指文件系统事件发生的次数统计

**例:使用 inotifywait** 

```bash
#监控一次性事件
inotifywait /data
#持续前台监控
inotifywait -mrq /data
#持续后台监控，并记录日志
inotifywait -o /root/inotify.log -drq /data --timefmt "%Y-%m-%d %H:%M" --format
"%T %w%f event: %e"
#持续前台监控特定事件
inotifywait -mrq /data --timefmt "%F %H:%M" --format "%T %w%f  event: %;e" -e
create,delete,moved_to,close_write,attrib
```

**rsync 软件包**：

rsync，rsync-daemon（CentOS 8） 

服务文件：/usr/lib/systemd/system/rsyncd.service 

配置文件：/etc/rsyncd.conf 端口：873/tcp 

**rsync命令**：

```bash
#Local:  
rsync [OPTION...] SRC... [DEST]
#Access via remote shell:
Pull:
rsync [OPTION...] [USER@]HOST:SRC... [DEST]
Push:
rsync [OPTION...] SRC... [USER@]HOST:DEST
#Access via rsync daemon:
Pull:
rsync [OPTION...] [USER@]HOST::SRC... [DEST]
rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
Push:
rsync [OPTION...] SRC... [USER@]HOST::DEST
rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
```

rsync 有三种工作方式： 

1. 本地文件系统上实现同步。命令行语法格式为上述"Local"段的格式。
2. 本地主机使用远程 shell 和远程主机通信。命令行语法格式为上述"Access via remote shell"段的格式。
3. 本地主机通过网络套接字连接远程主机上的 rsync daemon。命令行语法格式为上述 "Access viarsync daemon"段的格式。



# 三. 防火墙

> **防火墙概念**

- 在计算机领域，防火墙(FireWall)就是基于预先定义的安全规则来监视和控制来往的 网络流量的网络安全系统。防火墙的核心是隔离，其将受信任的内部网络和不受信任的 外部网络隔离开。内部网络一般是公司的内部局域网，外部网络一般是 Internet。
- 一般防火墙工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查， 并在匹配某规则时由规则定义的行为进行处理的一组功能的组件，基本上的实现都是默认 情况下关闭所有的通过型访问，只开放允许访问的策略。

>  **防火墙分类**

- 按照防火墙的保护范围，防火墙通常被分为：

  **网络防火墙**: 网络防火墙在两个或更多的网络间监控和过滤流量，运行在网络设备上。 网络防火墙保护的是防火墙某一侧的网络(一般是局域网络)。

  **主机防火墙**: 主机防火墙运行在一般的电脑主机，并控制进出这些电脑的网络流量， 主机防火墙保护的范围是当前主机。

- 从实现方式上看，防火墙被分为：

  **硬件防火墙**: 在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件实现， 如：华为，天融信 Checkpoint，NetScreen 等

  **软件防火墙**: 运行于通用硬件平台上的防火墙应用软件，ISA --> Forefront TMG

- 从工作交互的网络协议层及划分：

  **网络层防火墙**: 只可以和 OSI 模型下四层的协议交互

  **应用层防火墙**: 运行应用层防火墙的设备可以叫代理服务器或代理网关，可以与 OSI 的七层协议交互。

> **Netfilter 中的 hook 函数**

- Netfilter 在内核中选取五个位置放了五个 hook(“勾子”) function(INPUT、OUTPUT、 FORWARD、PREROUTING、POSTROUTING)，而这五个 hook function 向用户开放， 用户可以通过一个命令工具(iptables)向其写入规则，规则由信息过滤表(table)组成， 信息过滤表包含控制 IP 包处理的规则集(ruleset)，规则被分组放在(chain)上。

- **三种数据包流动方向**

  **流入本机**:PREROUTING --> INPUT–>用户空间进程

  **流出本机**:用户空间进程 -->OUTPUT–> POSTROUTING

  **转发**:PREROUTING --> FORWARD --> POSTROUTING

![iptables](https://img-blog.csdnimg.cn/2019123117471156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lvdU9vcHM=,size_16,color_FFFFFF,t_70)

 **数据包大致传输过程** :

1. 当一个网络数据包进入网卡时，数据包首先进入 PREROUTING 链，内核根据数据包目的 IP 判断是否需 要转送出去
2. 如果数据包就是进入本机的，数据包就会沿着图向下移动，到达 INPUT 链。数据包到达 INPUT 链 后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过 OUTPUT 链，然后 到达 POSTROUTING 链输出
3. 如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过 FORWARD 链，然后到 达 POSTROUTING 链输出

```bash
iptables -N # 自定义一条新的规则链
iptables -E # 重命名自定义链；引用计数不为 0 的自定义链不能够被重命名，也不能被删除
iptables -X # 删除自定义的空的规则链
iptables -P # 设置默认策略；对 filter 表中的链而言，其默认策略有： 
   			# ACCEPT：接受 DROP：丢弃
iptables -vnL --line-numbers
iptables -A 
iptables -I INPUT 2 ...
iptables -D 2
iptables -R 
iptables -F # 清空指定规则
#  (1) 可以指明规则序号 (2) 可以指明规则本身
iptables -Z # 清零计数
# （iptables 的每条规则都有两个计数器 (1) 匹配到的报文的个数 (2) 匹配到的所有报文的大小之和）
```

## iptables 扩展匹配条件

**multiport 扩展** 以离散方式定义多端口匹配 

```bash
iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp -m multiport --dports 20:22,80 -j ACCEPT
```

**iprange 扩展** 指明连续的（但一般不是整个网络）ip 地址范围 源 IP 地址范围 `[!] --src-range from[-to]` 目标 IP 地址范围 `[!] --dst-range from[-to]` 

```bash
iptables -A INPUT -d 172.16.1.100 -p tcp --dport 80 -m iprange --src-range 172.16.1.5-172.16.1.10 -j DROP
```

**mac扩展** mac 模块可以指明源 MAC 地址 

```bash
iptables -A INPUT -s 172.16.0.100 -m mac  --mac-source  00:50:56:12:34:56 -j ACCEPT
iptables -A INPUT -s 172.16.0.100  -j REJECT
```

 **string 扩展** string 扩展用于对报文中的应用层数据做字符串模式匹配检测 

```bash
iptables -A OUTPUT -p tcp --sport 80 -m string --algo bm --from 42 --string "google" -j REJECT
```

**time 扩展** 根据将报文到达的时间与指定的时间范围进行匹配 

```bash
iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp --dport 80 -m time --timestart 14:30 --timestop 18:30 --weekdays Sat,Sun --kerneltz -j DROP
```

**connlimit 扩展** 根据每客户端 IP 做并发连接数数量匹配可防止 Dos(Denial of Service，拒绝服务)攻击 

```bash
iptables -A INPUT -d 172.16.100.10 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT
# --connlimit-upto #      ：连接的数量小于等于#时匹配
# --connlimit-above #     ：连接的数量大于#时匹配
```

**limit 扩展** 基于收发报文的速率做匹 令牌桶过滤器 

```bash
iptables -I INPUT -d 172.16.100.10 -p icmp --icmp-type 8 -m limit --limit 10/minute --limit-burst 5 -j ACCEPT
iptables -I INPUT 2 -p icmp -j REJECT
```

**state 扩展** state 扩展模块，可以根据"连接追踪机制"去检查连接的状态，较耗资源， 会消耗内存，使用 conntrack 机制：追踪本机上的请求和响应之间的关系 

- 状态类型

  `NEW`：新发出请求；连接追踪信息库中不存在此连接的相关信息条目，因此，将其 识别为第一次发出的请求

  `ESTABLISHED`：NEW 状态之后，连接追踪信息库中为其建立的条目失效之前期间内 所进行的通信状态

  `RELATED`：新发起的但与已有连接相关联的连接，如：ftp 协议中的数据连接与命令 连接之间的关系

  `INVALID`：无效的连接，如 flag 标记不正确

  `UNTRACKED`：未进行追踪的连接，如 raw 表中关闭追踪

 已经追踪到的并记录下来的连接信息库 `/proc/net/nf_conntrack` 

 调整连接追踪功能所能够容纳的最大连接数量 `/proc/sys/net/netfilter/nf_conntrack_max` 

 查看连接跟踪有多少条目 `/proc/sys/net/netfilter/nf_conntrack_count` 

 不同的协议的连接追踪时长 `/proc/sys/net/netfilter/nf_conntrack_generic_timeout` 

 **state 模块使用格式** :

```bash
iptables -A INPUT -d 172.16.1.10 -p tcp -m multiport --dports 22,80 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -s 172.16.1.10 -p tcp -m multiport --sports 22,80 -m state --state ESTABLISHED -j ACCEPT
```

 **开放被动模式的 ftp 服务** :

1.  装载 ftp 连接追踪的专用模块： 跟踪模块路径：/lib/modules/kernelversion/kernel/net/netfilter1 

```bash
vim /etc/sysconfig/iptables-config
IPTABLES_MODULES=“nf_conntrack_ftp"
modproble  nf_conntrack_ftp
```

2.  放行请求报文： 命令连接：NEW, ESTABLISHED 数据连接：RELATED, ESTABLISHED 

```bash
iptables –I INPUT -d LocalIP -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -d LocalIP -p tcp --dport 21 -m state --state NEW -j ACCEPT
```

3.  放行响应报文 

```bash
iptables -I OUTPUT -s LocalIP -p tcp -m state --state ESTABLISHED -j ACCEPT
```

具体操作： 

```bash
yum install vsftpd
systemctl start vsftpd
modprobe nf_conntrack_ftp
iptables -F
iptables -A INPUT   -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -p tcp --dport 21 -m state --state NEW -j ACCEPT
iptables -A OUTPUT  -m state --state ESTABLISHED -j ACCEPT
iptables -P INPUT DROP
iptables -P OUTPUT DROP
iptables -vnL
```

##  iptables 规则保存

使用 iptables 命令定义的规则，手动删除之前，其生效期限为 kernel 存活期限

**持久保存规则** 

- CentOS 7,8 `iptables-save > /PATH/TO/SOME_RULES_FILE`
- CentOS 6

```bash
# 将规则覆盖保存至/etc/sysconfig/iptables文件中
service  iptables  save
```

**加载规则** 

- CentOS 7 重新载入预存规则文件中规则： `iptables-restore < /PATH/FROM/SOME_RULES_FILE` -n, --noflush：不清除原有规则 -t, --test：仅分析生成规则集，但不提交

- CentOS 6 

  ```bash
  # 会自动从/etc/sysconfig/iptables 重新载入规则
  service  iptables  restart
  ```

**开机自动重载规则** 

- 用脚本保存各 iptables 命令；让此脚本开机后自动运行 /etc/rc.d/rc.local 文件中添加脚本路径 /PATH/TO/SOME_SCRIPT_FILE

- 用规则文件保存各规则，开机时自动载入此规则文件中的规则 在/etc/rc.d/rc.local 文件添加 `iptables-restore < /PATH/FROM/IPTABLES_RULES_FILE`

- 定义 Unit File, CentOS 7，8 可以安装 iptables-services 实现 iptables.service 

  ```bash
  yum install iptables-services
  iptables-save > /etc/sysconfig/iptables
  systemctl enable iptables.service
  ```

### SNAT 实现

 SNAT：基于 nat 表的 target，适用于固定的公网 IP 

 例:10.0.1.0/24 网段的主机访问外部网络时，IP 数据包源地址被替换为 172.18.1.6-172.18.1.6 中的某一个地址

````bash
iptables -t nat -A POSTROUTING -s 10.0.1.0/24 ! –d 10.0.1.0/24 -j SNAT --to-source 172.18.1.6-172.18.1.9`
````

 另一个 target 为`MASQUERADE`，适用于动态的公网 IP，如拨号网络 

```bash
iptables -t nat -A POSTROUTING -s 10.0.1.0/24 ! –d 10.0.1.0/24 -j MASQUERADE
```



### DNAT 实现

 DNAT：nat 表的 target，适用于端口映射 

- 例如

```bash
iptables -t nat -A PREROUTING -s 0/0 -d 172.18.100.6 -p tcp --dport 22 -j DNAT --to-destination 10.0.1.22
iptables -t nat -A PREROUTING -s 0/0 -d 172.18.100.6 -p tcp --dport 80 -j DNAT --to-destination 10.0.1.22:8080
```

### 转发 REDIRECT

 REDIRECT，是 NAT 表的 target，通过改变目标 IP 和端口，将接受的包转发至同一个主机 的不同端口，可用于 PREROUTING OUTPUT 链 

 ```bash
iptables -t nat -A PREROUTING -d 172.16.100.10 -p tcp --dport 80 -j REDIRECT --to-ports 8080
 ```

# 四. Linux启动流程和内核管理

## 系统启动流程

### Centos6

```bash
1.加载BIOS的硬件信息，获取第一个启动设备 
2.读取第一个启动设备MBR的引导加载程序(grub)的启动信息 
3.加载核心操作系统的核心信息，核心开始解压缩，并尝试驱动所有的硬件设备 
4.核心执行init程序，并获取默认的运行信息 
5.init程序执行/etc/rc.d/rc.sysinit文件 
6.启动核心的外挂模块
7.init执行运行的各个批处理文件(scripts) 
8.init执行/etc/rc.d/rc.local
9.执行/bin/login程序，等待用户登录 
10.登录之后开始以Shell控制主机
```

 启动过程总结：`/sbin/init --> (/etc/inittab) --> 设置默认运行级别  --> 运行系统初始脚本、完成系统初始化 --> (关闭对应下需要关闭的服务)启动 需要启动服务 --> 设置登录终端` 

 或者：`POST --> Boot Sequence(BIOS) --> Boot Loader -->  Kernel(ramdisk) --> rootfs --> switchroot --> /sbin/init  -->(/etc/inittab, /etc/init/*.conf) --> 设定默认运行级别 -->  系统初始化脚本rc.sysinit --> 关闭或启动对应级别的服务 --> 启动终端` 

- 运行级别：为系统运行或维护等目的而设定0-6：7个级别 

```bash
0：关机 
1：单用户模式(root自动登录), single, 维护模式 
2：多用户模式，启动网络功能，但不会启动NFS；维护模式 
3：多用户模式，正常模式；文本界面 
4：预留级别；可同3级别 
5：多用户模式，正常模式；图形界面 
6：重启 

默认级别：3, 5 
切换级别：init # 
查看级别：
    runlevel
    who -r 
```

- /etc/rc.d/rc.sysinit: 系统初始化脚本,主要做以下事务

```bash
(1) 设置主机名 
(2) 设置欢迎信息 
(3) 激活udev和selinux  
(4) 挂载/etc/fstab文件中定义的文件系统 
(5) 检测根文件系统，并以读写方式重新挂载根文件系统 
(6) 设置系统时钟 
(7) 激活swap设备 
(8) 根据/etc/sysctl.conf文件设置内核参数 
(9) 激活lvm及software raid设备 
(10) 加载额外设备的驱动程序 
(11) 清理操作 
```

- grub配置文件：/boot/grub/grub.conf 

```
default=#: 设定默认启动的菜单项；落单项(title)编号从0开始 
timeout=#：指定菜单项等待选项选择的时长 
splashimage=(hd#,#)/PATH/XPM_FILE：菜单背景图片文件路径 
password [--md5] STRING: 启动菜单编辑认证 
hiddenmenu：隐藏菜单 
title TITLE：定义菜单项“标题”, 可出现多次 
root (hd#,#)：查找stage2及kernel文件所在设备分区；为grub的根 
kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核 
initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件 
password [--md5|--encrypted ] STRING: 启动选定的内核或操作系统时进行认证 
```

### Centos7

 **CentOS 7 引导顺序**  

```bash
UEFi或BIOS初始化，运行POST开机自检 
选择启动设备 
引导装载程序, centos7是grub2 
加载程序的配置文件： 
    /etc/grub.d/   
    /etc/default/grub  
    /boot/grub2/grub.cfg 
加载initramfs驱动模块 
加载内核选项 
内核初始化，centos7使用systemd代替init  
执行initrd.target所有单元，包括挂载/etc/fstab 
从initramfs根文件系统切换到磁盘根目录 
systemd执行默认target配置，配置文件/etc/systemd/system/default.target 
systemd执行sysinit.target初始化系统及basic.target准备操作系统 
systemd启动multi-user.target下的本机与服务器服务 
systemd执行multi-user.target下的/etc/rc.d/rc.local 
Systemd执行multi-user.target下的getty.target及登录服务 
systemd执行graphical需要的服务 
```

- 手动在grub命令行接口启动系统 

```bash
grub> root (hd#,#) 
grub> kernel /vmlinuz-VERSION-RELEASE ro root=/dev/DEVICE  
grub> initrd /initramfs-VERSION-RELEASE.img 
grub> boot 
```

**grub 配置文件**

```bash
[root@lab-server2 ~]# ll /boot/grub2/grub.cfg 
-rw-r--r--. 1 root root 4465 Dec 31 08:43 /boot/grub2/grub.cfg
```

### 破解CentOS7的root口令方法一

```bash
1.启动时任意键暂停启动 
2.按e键进入编辑模式 
3.将光标移动linux16开始的行，添加内核参数rd.break 
4.按ctrl-x启动  
5.mount –o remount,rw  /sysroot 
6.chroot /sysroot 
7.passwd root 
8.touch /.autorelabel 
9.exit 
10.reboot 
```

### 破解CentOS7的root口令方法二

```bash
1.启动时任意键暂停启动 
2.按e键进入编辑模式 
3.将光标移动linux16开始的行，改为rw init=/sysroot/bin/sh 
4.按ctrl-x启动  
5.hchroot /sysroot 
6.passwd root 
7.touch /.autorelabel 
8.exit 
9.reboot 
```

### 修复GRUB2

```bash
GRUB“the Grand Unified Bootloader” 
    引导提示时可以使用命令行界面 
    可从文件系统引导 
主要配置文件 /boot/grub2/grub.cfg 
修复配置文件 
    grub2-mkconfig > /boot/grub2/grub.cfg 
修复grub 
    grub2-install /dev/sda  BIOS环境 
    grub2-install  UEFI环境 
调整默认启动内核 
    vim /etc/default/grub 
    GRUB_DEFAULT=0 
```



## 内核管理

**sysctl命令查看当前生效的内核参数**

- 默认配置文件：/etc/sysctl.conf 

-  (1) 设置某参数  `sysctl -w parameter=VALUE`

-  (2) 通过读取配置文件设置参数  `sysctl -p [/path/to/conf_file]`  

- (3) 查看所有生效参数  `sysctl -a`


#### 内核常用参数

| 参数                                                         | 对应文件                                | 备注                                                         |
| ------------------------------------------------------------ | --------------------------------------- | ------------------------------------------------------------ |
| net.core.somaxconn = 4096                                    | /proc/sys/net/core/somaxconn            | 选项默认值是128，这个参数用于调节系统同时发起的tcp连接数，在高并发请求中，默认的值可能会导致连接超时或重传，因此，需要结合并发请求数来调节此值 |
| vm.swappiness = 1                                            | /proc/sys/vm/swappiness                 | 这个参数定义了系统对swap的使用倾向，centos7默认值为30，值越大表示越倾向于使用swap。可以设为0，这样做并不会禁止对swap的使用，只是最大限度地降低了使用swap的可能性 |
| net.ipv4.ip_forward = 1                                      | /proc/sys/net/ipv4/ip_forward           | 开启路由转发功能                                             |
| net.ipv4.icmp_echo_ignore_all = 1                            | /proc/sys/net/ipv4/icmp_echo_ignore_all | 禁ping                                                       |
| vm.drop_caches                                               | /proc/sys/vm/drop_caches                | 用来控制是否清空文件缓存：默认是0；1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存 |
| fs.file-max = 1020000                                        | /proc/sys/fs/file-max                   | 系统级别的可打开文件句柄数                                   |
| ulimit -n                                                    | /etc/security/limits.conf               | 限制经过PAM模块认证的用户打开的文件句柄数：* soft nofile 65535         * hard nofile 65535 |
| net.ipv4.tcp_syncookies = 1                                  | /proc/sys/net/ipv4/tcp_syncookies       | 开启SYN Cookies，当SYN等待队列溢出时，启用cookies来处理，可以防范少量的SYN攻击，默认为0，表示关闭 |
| net.ipv4.tcp_tw_reuse = 1                                    | /proc/sys/net/ipv4/tcp_tw_reuse         | 允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 |
| net.ipv4.tcp_tw_recycle = 1                                  | /proc/sys/net/ipv4/*                    | 允许将TIME_WAIT sockets快速回收以便利用，默认为0，表示关闭，需要同时开启 net.ipv4.tcp_timestamps 才能生效 |
| net.ipv4.tcp_timestamps = 1                                  | /proc/sys/net/ipv4/*                    | 默认为1                                                      |
| net.ipv4.tcp_fin_timeout = 30                                | /proc/sys/net/ipv4/*                    | 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。默认是60s |
| net.ipv4.ip_local_port_range = 1024 65500                    | /proc/sys/net/ipv4/*                    | 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65500 |
| net.ipv4.tcp_max_syn_backlog = 8192                          | /proc/sys/net/ipv4/*                    | 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 |
| net.ipv4.tcp_max_tw_buckets = 5000                           | /proc/sys/net/ipv4/*                    | 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。 |
| net.ipv4.ip_nonlocal_bind = 1                                | /proc/sys/net/ipv4/ip_nonlocal_bind     | 此参数表示是否允许服务绑定一个本机不存在的IP地址； 使用场景：有些服务需要依赖一个vip才能启动，但是此vip不在本机上，当vip飘移到本机上时才存在；但是服务又需要提前启动，例如haproxy,nginx等代理需要绑定vip时； 0：默认值，表示不允许服务绑定一个本机不存的地址 1：表示允许服务绑定一个本机不存在的地址 |
| vm.overcommit_memory = 1                                     |                                         | vm.overcommit_memory：表示系统允许内存的分配情况 0：默认值；     表示内核将检查是否有足够的可用内存供应用进程使用；     如果有足够的可用内存，内存申请允许；     否则，内存申请失败，并把错误返回给应用进程。 1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。redis要把此参数设为1； 2：     表示允许分配的内存为：物理内存*vm.overcommit_ratio+交换空间;      与参数vm.overcommit_ratio结合使用； |
| cat /proc/meminfo \| awk '{print $1,$2/1024 " Mb"}' \| grep "Commit" |                                         | 查看系统中可提交的内存和已经申请的内存：   CommitLimit：表示系统可分配的内存     Committed_AS：表示系统已经分配的内存 |
| kernel.msgmax                                                |                                         | 进程间的通信需要依靠内核来进行管理；是通过消息列队来传递消息； 以字节为单位，规定消息的单大值； 默认为65536，即64k； 此值不能超过kernel.msgmnb的值，msgmnb限定了消息队列的最大值； |
| kernel.msgmnb                                                |                                         | 以字节为单位，规定了一个消息队列的最大值； 默认值为：65536，即64k； |
| kernel.mni                                                   |                                         | 指定消息队列的最大个数；                                     |
| kernel.shmall                                                |                                         | 以**页**为单位，控制共享内存总量；Linux一个内存页大小为4kb； |
| kernel.shmmax                                                |                                         | 定义单个共享内存段的最大值;  shmmax 设置应该足够大，设置的过低可能会导致需要创建多个共享内存段； |
| kernel.shmmni                                                |                                         | 定义共享内存段的个数，默认为4096；                           |
| net.ipv4.tcp_rmem = 4096/87380/67108864  net.ipv4.tcp_wmem = 4096/65536/67108864 |                                         | 增加tcp缓冲区大小，tcp_rmem表示接受数据缓冲区范围，tcp_wmem表示发送数据缓冲区范围，单位Byte，最大64M |
| net.ipv4.tcp_retries2 = 5                                    |                                         | TCP失败重传次数,默认值15，意味着重传15次才彻底放弃，可减少到5，以尽早释放内核资源;在通讯过程中（已激活的sock），数据包发送失败后，内核要重试发送多少次后才决定放弃连接 |

### 内核编译

#### 1.前提：

```
(1) 准备好开发环境 
(2) 获取目标主机上硬件设备的相关信息 
(3) 获取目标主机系统功能的相关信息 
    例如:需要启用相应的文件系统 
(4) 获取内核源代码包 
     www.kernel.org 
```

#### 2.开发环境准备

```
包组 
    Development Tools 
目标主机硬件设备相关信息 
    CPU： 
    cat /proc/cpuinfo 
    x86info -a 
    lscpu 
PCI设备： 
    lspci 
        -v 
        -vv 
    lsusb 
        -v 
        -vv 
块设备 
    lsblk 
了解全部硬件设备信息 
    hal-device：CentOS 6 
```

#### 3.步骤

```
安装开发包组 
下载源码文件 
.config：准备文本配置文件 
make menuconfig：配置内核选项 
make [-j #]  或者用两步实现： make -j # bzImage ; make -j # modules 
make modules_install：安装模块 
make install ：安装内核相关文件 
    安装bzImage为 /boot/vmlinuz-VERSION-RELEASE 
    生成initramfs文件 
    编辑grub的配置文件 
```

#### 编译内核两大步

- 1.配置内核选项 

```
支持“更新”模式进行配置：make help 
(a) make config：基于命令行以遍历的方式配置内核中可配置的每个选项 
(b) make menuconfig：基于curses的文本窗口界面 
(c) make gconfig：基于GTK (GNOME）环境窗口界面 
(d) make xconfig：基于QT(KDE)环境的窗口界面 
支持“全新配置”模式进行配置 
(a) make defconfig：基于内核为目标平台提供的“默认”配置进行配置 
(b) make allyesconfig: 所有选项均回答为“yes“ 
(c) make allnoconfig: 所有选项均回答为“no“ 
```

- 2.编译 

```
全编译:make [-j #]  
编译内核的一部分功能： 
(a) 只编译某子目录中的相关代码 
    cd /usr/src/linux 
    make dir/ 
(b) 只编译一个特定的模块 
    cd /usr/src/linux 
    make dir/file.ko 
    示例：只为e1000编译驱动： 
        make drivers/net/ethernet/intel/e1000/e1000.ko
```

#### 卸载内核

```
删除/lib/modules/目录下不需要的内核库文件 
删除/usr/src/linux/目录下不需要的内核源码 
删除/boot目录下启动的内核和内核映像文件 
更改grub的配置文件，删除不需要的内核启动列表 
    centos7:vim /boot/grub2/grub.cfg 
           :/menuentry
    centos8:
          rm -f /boot/loader/entries/7e3e9120767340a8bd946a83d7c3b84d-$(uname -r)-80.el8.x86_64.conf
```



## systemd服务

 **Systemd**：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激 活系统资源，服务器进程和其它进程  

` POST --> Boot Sequence --> Bootloader --> kernel + initramfs(initrd) --> rootfs --> /sbin/init  `

**centos6 --> centos7:**

```
启动：service name start ==> systemctl start name.service 
停止：service name stop ==> systemctl stop name.service 
重启：service name restart ==> systemctl restart name.service 
状态：service name status ==> systemctl status name.service 

禁止自动和手动启动： systemctl mask name.service
取消禁止： systemctl unmask name.service 

服务查看

    查看某服务当前激活与否的状态： systemctl is-active name.service
    查看所有已经激活的服务：      systemctl list-units --type|-t service
    查看所有服务：              systemctl list-units --type service --all|-a

    重新加载配置 systemctl reload sshd.service
    列出活动状态的所有服务单元 systemctl list-units --type=service
    列出所有服务单元 systemctl list-units --type=service --all
    查看服务单元的启用和禁用状态 systemctl list-unit-files --type=service
    列出失败的服务 systemctl --failed --type=service
    列出依赖的单元 systemctl list-dependencies sshd
    验证sshd服务是否开机启动 systemctl is-enabled sshd
    禁用network，使之不能自动启动,但手动可以 systemctl disable network
    启用network systemctl enable network
    禁用network，使之不能手动或自动启动 systemctl mask network
    启用network systemctl unmask network

```



**运行级别** 

```bash
0  ==> runlevel0.target, poweroff.target 
1  ==> runlevel1.target, rescue.target 
2  ==> runlevel2.target, multi-user.target 
3  ==> runlevel3.target, multi-user.target 
4  ==> runlevel4.target, multi-user.target 
5  ==> runlevel5.target, graphical.target 
6  ==> runlevel6.target, reboot.target 
```

 获取默认运行级别：  `systemctl get-default` 

**传统命令init，poweroff，halt，reboot都成为systemctl的软链接** 

```bash
关机:systemctl halt、systemctl poweroff 
重启:systemctl reboot 
挂起:systemctl suspend 
休眠:systemctl hibernate 
休眠并挂起:systemctl hybrid-sleep 
```



# 五. Linux网络协议与管理



 **ISO网络7层模型**：

- 物理层：其为启动、维护和关闭物理链路规定了：电器特性、机械特性、过程特性和功能特性 

- 数据链路层： 有时也称网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡 
- 网络层： 有时也称作互联网层，其主要负责处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议） 
- 传输层： 运输层主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议） 
- 会话层
- 表示层
- 应用层： 应用层负责处理特定的应用程序细节 



## 数据链路层

**在TCP/IP协议族中，数据链路层主要有三个目的**：

- （1）为IP模块发送和接收IP数据报；
- （2）为ARP模块发送ARP请求和接收ARP应答；
- （3）为RARP发送RARP请求和接收RARP应答。



**环回接口**

 大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现 



## 网络层

**IP协议**

 IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。许多刚开始接触TCP/IP的人对IP提供不可靠、无连接的数据报传送服务感到 很奇怪。IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了 一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制 

-  **不可靠（unreliable）**的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP） 
-  **无连接（connectionless）**这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达 

**IP数据报文格式**：

![](F:\M39-Slides-Edited-notes\md_notes\Interview_exam_soluton_collection\png\20191025085607291.png)

**ICMP协议**：

Internet控制报文协议，主要用于传递差错报文和其他信息。ICMP报文通常被IP层或者更高层协议(TCP/UDP)使用。某些ICMP报文用来将差错报文传给用户进程 



**IGMP协议**：

Internet组管理协议，用于支持主机和路由器进行多播。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。和ICMP一样，IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。IGMP报文通过IP首部中协议字段值为2来指明



**最大传输单元MTU**

以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU，最大传输单元。不同类型的网络大多数都有一个上限。如果I P层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU



**路径MTU**

当在同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要的。但是如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上
 不一定是一致的 



## 传输层

### TCP协议

尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务 

 **面向连接**：

意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁

**可靠性的保证**：

- 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段（segment） 
-  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。TCP协议使用了自适应的超时及重传策略 
-  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。在第21章我们将了解TCP协议中自适应的超时及重传策略 
-  TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发） 
-  既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层 。 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据 

-  TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只
   允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲
   区溢出 

两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端； 另外，TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层
解释 

```bash
这种对字节流的处理方式与Unix操作系统对文件的处理方式很相似。Unix的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对Unix的内核来说，它无法区分一个二进制文件与一个文本文件
```

 **TCP报文段被封装在一个IP数据报中** ：

![](F:\M39-Slides-Edited-notes\md_notes\Interview_exam_soluton_collection\png\2019102511005542.png)



-  每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接， 插口对（socket pair）(包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组)可唯一确定互联网络中每个TCP连接的双方 

-  序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达232－1后又从0开始 
-  TCP可以表述为一个没有选择确认或否认的滑动窗口协议（滑动窗口协议用于数据传输）。我们说TCP缺少选择确认是因为TCP首部中的确认序号表示发方已成功收到字节，但还不包含确认序号所指的字节。当前还无法对数据流中选定的部分进行确认 、
- 在TCP首部中有6个标志比特。它们中的多个可同时被设置为1。 
  - URG 紧急指针（urgentpointer）有效。
  - ACK 确认序号有效。
  - PSH 接收方应该尽快将这个报文段交给应用层。
  - RST 重建连接。
  - SYN 同步序号用来发起一个连接。
  - FIN 发端完成发送任务
-  TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。新的窗口刻度选项允许这个值按比例变化以提供更大的窗口 
-  **检验和**：覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似 
-  只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。 
-  TCP报文段中的数据部分是可选的。接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段 

### 三次握手

 TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接 。

- 1)请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）。这个SYN段为报文段1。

- 2)服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。

- 3)客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。通过这三个报文后就建立连接了。这个过程也称为三次握手(three-way handshake)。

![](F:\M39-Slides-Edited-notes\md_notes\Interview_exam_soluton_collection\png\20191025110255379.png)

### 四次挥手

 建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭（half-close）造成的。既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须 单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端已经终止了那个方向的数据传 送。发送FIN通常是应用层进行关闭的结果 。

 收到一个FIN只意味着在这一方向上没有数据流动。**一个TCP连接在收到一个FIN后仍能发送数据**。而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做。  首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭，但也可能双方都执行主动关闭 

当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样， 一个FIN将占用一个序号。同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。 接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN（报文段6），客户必须发回 一个确认，并将确认序号设置为收到序号加1（报文段7）。 发送FIN将导致 应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的。连接通常是由客户端发起的， 这样第一个SYN从客户传到服务器。每一端都能主动关闭这个连接（即首先发送FIN）。然而，一般 由客户端决定何时终止连接，因为客户进程通常由用户交互控制，用户会键入诸如“quit”一样的 命令来终止进程 

#### 2MSL等待状态

 TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段 

```bash
RFC 793 [Postel 1981c] 指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟，或2分钟。
```

在实际应用中，对IP数据报TTL的限制是基于跳数，而不是定时器。对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用

### UDP协议

 UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。UDP数据报被封装成一份IP数据报的格式 

#### 分用

 当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用(Demultiplexing) 

## 传统的IP地址分类

- 具体的网络数、所容纳的主机数及私网地址等如下：

```bash
1.A类地址：
  0000 0000 - 0111 1111: 1-127 
  网络数：126, 127 
  每个网络中的主机数：2^24-2 
  默认子网掩码：255.0.0.0 
  私网地址：10.0.0.0 
2.B类地址：
  1000 0000 - 1011 1111：128-191 
  网络数：2^14
  每个网络中的主机数：2^16-2 
  默认子网掩码：255.255.0.0 
  私网地址：172.16.0.0-172.31.0.0 
3.C类地址：
  1100 0000 - 1101 1111: 192-223 
  网络数：2^21 
  每个网络中的主机数：2^8-2 
  默认子网掩码：255.255.255.0 
  私网地址：192.168.0.0-192.168.255.0 
4.D类地址：
  D类地址为组播地址
  1110 0000 - 1110 1111: 224-239 
```

- 特殊地址

```bash
0.0.0.0 
    0.0.0.0不是一个真正意义上的IP地址。它表示所有不清楚的主机和目的网络 
255.255.255.255 
    限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机 
127.0.0.1～127.255.255.254 
    本机回环地址，主要用于测试。在传输介质上永远不应该出现目的地址为“127.0.0.1”的数据包 
224.0.0.0到239.255.255.255 
    组播地址，224.0.0.1特指所有主机，224.0.0.2特指所有路由器。224.0.0.5指OSPF路由器，地址多用于一些特定的程序以及多媒体程序 
169.254.x.x 
    如果Windows主机使用了DHCP自动分配IP地址，而又无法从DHCP服务器获取地 址，系统会为主机分配这样地址
```



## CIDR表示的网络地址

- CIDR全称为：无类域内路由选择（Classless Inter-Domain Routing）
- 描述IP和网段时，子网掩码一般和IP成对出现，例如：192.168.123.234 255.255.255.0
   但是这种表示方法比较长，另一种比较方便的表示方法就叫CIDR表示法。其直接将子网掩码为1的位数写在IP地址的后面。例如：192.168.123.234 255.255.255.0 可以改写为：192.168.123.234/24(24就是子网掩码全为1的位数)。



## 路由的概念

- 每个数据包要在不同网络中传输，都需要进行路由，每次路由时都根据路由表中的记录决定下一跳该给谁。
- 路由分为： 
  - 主机路由
  - 网段路由
  - 默认路由

## Linux网络管理命令及配置

![](https://img-blog.csdnimg.cn/20191025134727495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lvdU9vcHM=,size_16,color_FFFFFF,t_70)



![](https://img-blog.csdnimg.cn/20191025134807866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lvdU9vcHM=,size_16,color_FFFFFF,t_70)

## 多网卡绑定

将多块网卡绑定同一IP地址对外提供服务，可以实现高可用或者负载均衡。直接给两块网卡设置同 一IP地址是不可以的。通过bonding，虚拟一块网卡对外提供连接，物理网卡的被修改为相同的MAC地址。

Bonding工作模式

| mode                                                         | explain                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Mode 0 (balance-rr)                                          | 轮询（Round-robin）策略，从头到尾顺序的在每 一个slave接口上面发送数据包。本模式提供负载均衡和容错的能力 |
| Mode 1 (active-backup)                                       | 活动-备份（主备）策略，只有一个slave被激活，当且仅当活动的slave接口失败时才会激活其他slave.为了避免交换机发生混乱此时绑定的MAC地址只有一个外部端口上可见 |
| Mode 3 (broadcast)                                           | 广播策略，在所有的slave接口上传送所有的报文,提供容错能力     |
| active-backup、balance-tlb 和 balance-alb  模式不需要交换机的任何特殊配置。其他绑定模式需要配置交换机以便整合链接。如：Cisco 交换机需要在模式 0、2 和 3 中使用  EtherChannel，但在模式4中需要LACP和EtherChannel |                                                              |

 **桥接：**把一台机器上的若干个网络接口“连接”起来。其结果是，其中一个网收到的报文会被复制给其他网口并发送出去。以使得网口之间的报文能够互相转发。网桥就是这样一个设备，它有若干个网口，并且这些网口是桥接起来的。与网桥相连的主机就能通过交换机的报文转发而互相通信。 



# 六. 进程管理和任务计划

## 内核功能

| 内核功能                     | 解释                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 进程调度                     | 现在的计算机一般会有多个物理核心用来执行程序的指令。Linux系统是一个抢占式多任务(preemptive  multitasking)的操作系统,多任务就意味着多个进程可以同时驻留在内存中得到CPU的处理，抢占式就意味着是哪个进程使用CPU或者使用多久的规则由内核进程调度器决定而不是CPU自己决定处理哪个进程 |
| 内存管理                     | 目前内存已近越来越大，但是软件体积也同样在增长；计算机的物理内存仍然是比较稀缺的资源，这就需要内核合理的管理分配内存给系统的各个进程 |
| 提供文件系统功能             | 内核能够在磁盘上创建特定文件系统，以允许文件被创建，复制更新和删除等 |
| 创建和销毁进程               | 内核可以加载某个程序到内存，并为其分配其运行所需要的资源(CPU、内存、对文件的访问等)，在内存中运行的某个程序的实例就叫做进程。当程序被内核销毁或者自己运行结束后，内核还需要保证其使用的资源被释放以便于后续进程重用 |
| 访问设备                     | 连接到计算机上的设备(如：麦克风、显示器、键盘鼠标、磁盘和磁带、软盘等)是的计算机内部和计算机之间及计算机和外部世界可以进行信息交互，允许计算机进行输入、输出等操作。内核为每个上层应用程序提供了一个标准的接口来访问设备，同时仲裁多个进程对设备的访问 |
| 提供网络功能                 | 内核代替用户进程收发网络数据。                               |
| 提供系统调用应用程序编程接口 | 进程可以通过一个入口请求内核完成多种操作，该入口就是系统调用 |
| 提供虚拟个人电脑抽象功能     | 在linux系统，多个用户可以同时登陆系统并进行不同的操作，内核提供了一个抽象层来保证各个用户的操作和对设备的使用的隔离性 |

## 程序？进程？线程？

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| 程序 | 一般程序以两种形式存在：源代码的形式和二进制可执行程序的形式。源代码是人类可以读的文本(包括一系列的使用列如C语言编写的语句)。程序要被CPU执行，必须编译链接为计算机可以识别的二进制机器码指令(windows内的.exe文件；linux下的.o文件等)；二者被认为是同义词，都代表程序。 |
| 进程 | 简单的说，一个进程就是一个正在执行的程序的实例。当一个程序被执行时，内核会将该程序的指令加载进内存，分配内存空间给程序变量并设置相应的数据结构来记录该进程的信息(Linux内核对该种数据结构的实现叫task list，保存有进程ID、退出状态、用户ID和组ID等)。因此，进程也可以描述为：运行的程序及其包括的数据和操作。 |
| 线程 | 在现代的UNIX实现版中，每个进程可以有多个线程运行。一个理解线程比较好的表述是：共享同一块内存空间和其他属性的轻量级进程的集合。每个线程都执行同一个代码块并共享相同的数据区域和堆。然而，每个线程都有自己的栈空间(包含本地变量和函数调用连接信息)。线程之间可以通过其共享的全局变量进行通讯，进程亦可以通过IPC和同步机制进行通讯。 |

## 用户模式和内核模式

 现代处理器架构一般都允许CPU在至少两个不同模式运行：用户模式(user mode)和内核模式 (kernel mode：内核模式有时候也被称为监管模式)，CPU自带的硬件指令允许在两个模式之间切换。 相应地，虚拟内存的某部分可被标记为用户空间(user space)或内核空间(kernel space)。当在 用户模式运行某进程时CPU只可以访问标记为用户控件的内存区域，尝试访问被标记为内核空间的内存 将会导致一个硬件异常(hardware exception)错误。 



## 进程的状态

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| 创建状态 | 进程在创建时需要申请一个空白PCB(process control block进程控 制块)，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完 成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态 |
| 就绪状态 | 进程已准备好，已分配到所需资源，只要分配到CPU就能够立即运行  |
| 执行状态 | 进程处于就绪状态被调度后，进程进入执行状态                   |
| 阻塞状态 | 正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行进程受到阻塞。在满足请求时进入就绪状态等待系统调用 |
| 终止状态 | 进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行 |

##  状态之间转换的四种情况 

|            |                                                              |
| ---------- | ------------------------------------------------------------ |
| 运行to就绪 | 1，主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；2，在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态 |
| 就绪to运行 | 运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU |
| 运行to阻塞 | 正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求 |
| 阻塞to就绪 | 进程所等待的事件已经发生，就进入就绪队列                     |

## Linux的进程状态

- linux进程类型： 守护进程: daemon,在系统引导过程中启动的进程，和终端无关进程 前台进程：跟终端相关，通过终端启动的进程 注意：两者可相互转化
- linux进程状态： 运行态：running 就绪态：ready 睡眠态： 可中断睡眠态：interruptable 不可中断睡眠态：uninterruptable 停止态：stopped,暂停于内存，但不会被调度，除非手动启动 僵死态：zombie，结束进程，父进程结束前，子进程不关闭

**Linux进程优先级**

- 系统优先级：数字越小，优先级越高
- 0-139：每个优先级有140个运行队列和过期队列
- 实时优先级: 99-0   值最大优先级最高
- nice值：-20到19，对应系统优先级100-139



## 什么是作业?

- 在Linux中的作业是指正在运行的还没有结束的命令或者任务。Linux是个支持多任务的操作系统， 其允许多个命令同时执行(多核CPU真正的同时执行；单核CPU并发执行)。每个正在进行的作业被唯 一的作业号所标识。
- 要查看和控制作业主要使用以下命令 
  - jobs  列出正在运行或者挂起的作业
  - fg    将作业转换为前台作业
  - bg    将作业转换为后台作业
  - stop  挂起作业(Ctrl + z)
  - kill  结束作业(Ctrl + c)

 Linux中某个命令或脚本默认运行时为前台进程，可以使用Ctrl + c结束其；如果发起该命令或者 脚本的终端被关闭，那么该进程也就结束；这不利于需要长时间做某事的作业运行，在运行某命令或则 脚本时可以在其后加上&符号来使其以后台作业的方式运行，这样即使使用Ctrl+c或者关闭终端也不会 导致作业被终止 

![](F:\M39-Slides-Edited-notes\md_notes\Interview_exam_soluton_collection\png\20191027190430520.png)



## Linux任务计划

### 未来某时间点执行一次的任务

- 使用at命令来定义未来某时间点执行一次的任务
- at命令所在包：at

### 未来周期性执行的任务

- 计划周期性执行的任务提交给crond，到指定时间会自动运行
- 系统cron任务：系统维护的周期性作业,位于： /etc/crontab文件内，一般只有root可以更改。
- 用户cron任务：使用crontab命令来创建用户各自的周期性任务
- 日志：/var/log/cron
- 使用crontab命令来定义周期性计划任务

```bash
[root@centos7 ~]#cat /etc/crontab
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# For details see man 4 crontabs
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
```

- 例如：晚上9点10分以用户steve的身份运行echo命令

```bash
10 21 * * *  steve  /bin/echo “Hello there!!”
```

- 例子:每3小时echo和wall命令 

```bash
0 */3 * * * steve /bin/echo “Done something!”; wall “Done something again!”
```

### 用户计划任务 

* crontab命令定义    

* 每个用户都有专用的cron任务文件：/var/spool/cron/USERNAME   

*  crontab命令：

  ```bash
  crontab [-u user] [-l | -r | -e] [-i] 
  -l 列出所有任务  
  -e 编辑任务  
  -r 移除所有任务  
  -i 同-r一同使用，以交互式模式移除指定任务  
  -u user 仅root可运行，指定用户管理cron任务
  ```

### Linux系统性能监控和管理命令

| 命令    | 作用                                                         | 备注 |
| ------- | ------------------------------------------------------------ | ---- |
| pstree  | pstree命令以树状结构显示当前系统进程                         |      |
| ps      | ps是linux系统中查看进程的有力工具之一。man帮助指明其用于报告当前系统所有进程的一个快照 |      |
| nice    | 使用nice命令指定一个调度优先级来运行某程序                   |      |
| renice  | renice命令可以更改一个正在运行的进程的优先级                 |      |
| pgrep   | pgrep和pkill命令大部分选项相同，也就是大部分功能相同；但是pgrep一般用来基于进程名搜索某进程，<br/> pkill一般基于进程名来发送相关信号给某进程 |      |
| kill    | kill命令一般用来结束某进程，但是其还有其他功能，用于发送特定的信号给相关进程来控制某进程 |      |
| killall | killall命令单纯的基于进程名来结束某进程                      |      |
| top     | 监控系统进程                                                 |      |
| htop    | 其使用不同的颜色来标识不同的信息，甚至支持鼠标点击相应的选项；来自EPEL源 |      |
| free    | 查看内存空间使用情况                                         |      |
| vmstat  | 命令查看虚拟内存信息                                         |      |
| iostat  | 统计CPU和设备IO信息                                          |      |
| iftop   | 显示带宽使用情况                                             |      |
| pmap    | 显示某进程对应的内存映射                                     |      |
| dstat   | dstat命令用来统计系统资源(代替vmstat和iostat)                |      |
| iotop   | iotop命令用来监视磁盘I/O使用状况                             |      |
| nload   | nload命令查看网络实时吞吐量                                  |      |

- lsof：列出打开的文件

```bash
查看由登陆用户启动而非系统启动的进程 
  lsof /dev/pts/1 
指定进程号，可以查看该进程打开的文件 
  lsof -p 9527
查看指定程序打开的文件 
  lsof -c httpd 
查看指定用户打开的文件 
  lsof -u root | more
查看指定目录下被打开的文件 
  lsof +D /var/log/
  lsof +d /var/log/ 
参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件
```

- lsof示例

```bash
查看所有网络连接 
  lsof -i –n 
  lsof -i@127.0.0.1
  通过参数-i查看网络连接的情况，包括连接的ip、端口等以及一些服务的连接情况，例如：sshd等。也可以通过
指定ip查看该ip的网络连接情况 
查看端口连接情况 
  lsof -i :80 -n 
  通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等
查看指定进程打开的网络连接 
  lsof -i –n -a -p 9527
  参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程 
查看指定状态的网络连接 
  lsof -n -P -i TCP -s TCP:ESTABLISHED
  -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态通过多个参数可以
清晰的查看网络连接情况、协议连接情况等
恢复删除文件 
  lsof |grep /var/log/messages 
  rm -f /var/log/messages 
  lsof |grep /var/log/messages 
  cat /proc/653/fd/6 
况 
查看端口连接情况 
  lsof -i :80 -n 
  通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等
查看指定进程打开的网络连接 
  lsof -i –n -a -p 9527
  参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进程 
查看指定状态的网络连接 
  lsof -n -P -i TCP -s TCP:ESTABLISHED
  -n:no host names, -P:no port names,-i TCP指定协议，-s指定协议状态通过多个参数可以
清晰的查看网络连接情况、协议连接情况等
恢复删除文件 
  lsof |grep /var/log/messages 
  rm -f /var/log/messages 
  lsof |grep /var/log/messages 
  cat /proc/653/fd/6 
  cat /proc/653/fd/6 > /var/log/messages 
```



# 6.5 文本处理三剑客

## grep

## SED

## AWK



# 七. MySQL

## 索引

## 并发控制

## 主从复制

**主从复制，一主多从，主库提供读写功能，从库提供写功能**。当一个事务在master 提交成功时，会把binlog文件同步到从库服务器上落地为relay log给slave端执行，这个过程主库是不考虑从库是否有接收到binlog文件，有可能出现这种情况，当主库commit一个事务后，数据库发生宕机，刚好它的binlog还没来得及传送到slave端，这个时候选任何一个slave端都会丢失这个事务，造成数据不一致情况。 为了避免出现主从数据不一致的情况，MySQL引入了半同步复制，添加多了一个**从库反馈机制**，这个有两种方式设置：

- 主库执行完事务后，同步binlog给从库，从库ack反馈接收到binlog，主库提交commit，反馈给客户端，释放会话；
- 主库执行完事务后，主库提交commit ，同步binlog给从库，从库ack反馈接收到binlog，反馈给客户端，释放会话；

**缺点**：

- 写操作集中在MASTER服务器上；

- MASTER宕机后，需要人为选择新主并重新给其他的slave端执行change master（可自行写第三方工具实现，但是mysql的复制就是没提供，所以也算是弊端）

 于是乎，官方感应到民间怨气以及业界压力，于2016年12月12日正式发布了MySQL Group Replication

**那么，MySQL Group Replication可以提供哪些功能呢？**

- 多主，在同一个group里边的所有实例，每一个实例可以执行写操作，也就是每个实例都执行Read-Write
  - 注意一点，多主情况下，当执行一个事务时，需要确保同个组内的每个实例都认可这个事务无冲突异常，才可以commit，如果设置的是单主，其他实例ReadOnly，则不需要进行上面的判断
  - 多主情况下，事务并发冲突问题就凸显出来了，如何避免呢？数据库内部有一个认证程序，当不同实例并发对同一行发起修改，在同个组内广播认可时，会出现并发冲突，那么会按照先执行的提交，后执行的回滚
- 弹性，同个Group Replication中，节点的加入或者移除都是自动调整；如果新加入一个节点，该节点会自动从Group的其他节点同步数据，直到与其他节点一致；如果移除一个节点，那么剩下的实例会自动更新，不再向这个节点广播事务操作，当然，这里要注意，假设一个Group的节点有n个（max(n)=9，同个Group最多节点数为9），移除或者宕机的节点数应该小于等于 floor((n-1)/2) ，注意是向下取整；如果是单主模式，宕机的是单主，则人为选择新主后，其他节点也会自动从新主同步数据。

**故障探测（ Failure Detection）：**

Group Replication中有一个故障检测机制，会提供某些节点可能死掉的信息，然后广播给同一个Group的各个节点，如果确定宕机，那么组内的节点就会与它隔离开来，该节点即无法同步其他节点的传送过来的binlog events，也无法执行任何本地事务。

**配置MGR数据库要求**：

**innodb引擎**

  为什么需要使用innodb引擎呢？在MySQL Group Replication中，事务以乐观形式执行，但是在提交时检查冲突，如果存在冲突，则会在某些实例上回滚事务，保持各个实例的数据一致性，那么，这就需要使用到 事务存储引擎，同事Innodb提供一些额外的功能，可以更好的管理和处理冲突，所以建议 业务使用表格使用inndb存储引擎，类似于系统表格mysql.user使用MyISAM引擎的表格，因为极少修改及添加，极少出现冲突情况。

**主键**

  每个需要复制的表格都必须定义一个显式主键，注意跟隐式主键区分（使用Innodb引擎的表格，如果没有指定主键，默认选择第一个非空的唯一索引作为主键，如果没有，则自动创建一个6个字节的rowid隐式主键）。这个主键能在冲突发生时启动极其重要的作用，同时，能够有效提高relay log的执行效率。

**隔离级别**

  官网建议使用READ COMMITTED级别，除非应用程序依赖于REPLEATABLE READ，RC模式下没有GAP LOCK，比较好支持Innodb本身的冲突检测机制何组复制的内部分布式检测机制一起协同工作。不支持SERIALIZABLE隔离级别。

 **外键**

  不建议使用级联外键，如果旧库本身有外键，业务上无法去除并且使用的是多主模式，那么，请配置 group_replication_enforce_update_everywhere_check ，强制检查每个组成员的级联检查，避免多主模式下执行级联操作造成的检测不到的冲突。



## 备份和恢复



## 集群





# 八. Ansible



# 九. HTTP协议与HTTPD



# 十. LAMP/LNMP



# 十一. LVS



# 十二. Nginx



# 十三. HAProxy



# 十四. Tomcat



# 十五. ESXi



# 十六. Redis



# 十七. Docker



# 十八. Zabbix



# 十九. Gitlab&Jenkins



# 二十. ELK stack



# 二十一. 中间件



# 二十二. Kubernetes



# 二十三. OpenStack