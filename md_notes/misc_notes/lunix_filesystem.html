<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="generator" content="pandoc" />
    <meta name="author" content="Ian! D. Allen – idallen@idallen.ca – www.idallen.com" />
    <title>Unix/Linux File System – directories, inodes, hard links</title>
    <style type="text/css">
        code {
            white-space: pre;
        }
    </style>
    <link rel="stylesheet" href="common/ianstyles003.css" type="text/css" />
    <link rel="stylesheet" href="common/ianstyles004.css" type="text/css" />
    <meta name="author" content="Ian! D. Allen - www.idallen.com" />
    <link rel="shortcut icon" href="common/favicon.png" type="image/x-icon" />

</head>

<body class="pandoc-html ">
    <div id="header">
        <h1 class="title">Unix/Linux File System – directories, inodes, hard links</h1>
        <h2 class="author">Ian! D. Allen – <a href="mailto:idallen@idallen.ca">idallen@idallen.ca</a> – <a
                href="http://www.idallen.com/">www.idallen.com</a></h2>
        <h3 class="date">Winter 2013 - January to April 2013 - Updated 2019-03-01 04:02 EST</h3>
    </div>
    <ul>
        <li><a href="..">Course Home Page</a></li>
        <li><a href="course_outline.pdf">Course Outline</a></li>
        <li><a href="indexcgi.cgi">All Weeks</a></li>
        <li><a href="450_file_system.txt">Plain Text</a></li>
    </ul>
    <!--navbar1-->

    <div id="TOC">
        <p class="updated">
            Updated:

            2019-03-01 04:02 EST
        </p>
        <ul>
            <li><a href="#file-systems-contain-names-of-directories-and-files"><span class="toc-section-number">1</span>
                    File systems contain names of directories and files</a>
                <ul>
                    <li><a href="#files-are-a-list-of-bytes"><span class="toc-section-number">1.1</span> Files are a
                            list of bytes</a></li>
                    <li><a href="#even-hardware-devices-have-file-names"><span class="toc-section-number">1.2</span>
                            Even hardware devices have file names</a></li>
                </ul>
            </li>
            <li><a href="#things-are-stored-in-index-nodes-inodes"><span class="toc-section-number">2</span> Things are
                    stored in Index Nodes = Inodes</a>
                <ul>
                    <li><a href="#directories-map-names-to-inode-numbers"><span class="toc-section-number">2.1</span>
                            Directories map names to inode numbers</a></li>
                    <li><a href="#one-inode-many-names"><span class="toc-section-number">2.2</span> One inode, many
                            names</a></li>
                    <li><a href="#inodes-contain-pointers-to-disk-blocks"><span class="toc-section-number">2.3</span>
                            Inodes contain pointers to disk blocks</a></li>
                    <li><a href="#inodes-contain-attributes-owners-permissions-times-etc."><span
                                class="toc-section-number">2.4</span> Inodes contain attributes (owners, permissions,
                            times, etc.)</a></li>
                    <li><a href="#inodes-are-unique-inside-a-file-system"><span class="toc-section-number">2.5</span>
                            Inodes are unique inside a file system</a></li>
                    <li><a href="#inodes-are-a-fixed-resource"><span class="toc-section-number">2.6</span> Inodes are a
                            fixed resource</a></li>
                </ul>
            </li>
            <li><a href="#file-system-diagrams-are-wrong"><span class="toc-section-number">3</span> File System Diagrams
                    are Wrong</a></li>
            <li><a href="#directories-hold-only-names-and-inode-numbers"><span class="toc-section-number">4</span>
                    Directories hold only names and inode numbers</a>
                <ul>
                    <li><a href="#attributes-are-stored-with-the-inode-not-the-name"><span
                                class="toc-section-number">4.1</span> Attributes are stored with the inode, not the
                            name</a></li>
                    <li><a href="#damaged-directories-create-orphans"><span class="toc-section-number">4.2</span>
                            Damaged directories create orphans</a></li>
                </ul>
            </li>
            <li><a href="#multiple-names-hard-links"><span class="toc-section-number">5</span> Multiple names – hard
                    links</a>
                <ul>
                    <li><a href="#link-counts-count-names-ln-creates-rm-removes-only-a-name"><span
                                class="toc-section-number">5.1</span> Link counts count names; <code>ln</code> creates,
                            <code>rm</code> removes only a name</a></li>
                </ul>
            </li>
            <li><a href="#tracing-inodes-in-pathnames-ascii-art"><span class="toc-section-number">6</span> Tracing
                    Inodes in Pathnames – ASCII Art</a>
                <ul>
                    <li><a href="#slashes-separate-names-in-pathnames"><span class="toc-section-number">6.1</span>
                            Slashes separate names in pathnames</a></li>
                    <li><a href="#names-reside-above-the-things-they-name"><span class="toc-section-number">6.2</span>
                            Names reside above the things they name</a></li>
                    <li><a href="#tracing-pathname-1-homealexfoobar"><span class="toc-section-number">6.3</span> Tracing
                            Pathname 1: <code>/home/alex/foobar</code></a></li>
                    <li><a href="#tracing-pathname-2-homealexliteraturebarfoo"><span
                                class="toc-section-number">6.4</span> Tracing Pathname 2:
                            <code>/home/alex/literature/barfoo</code></a></li>
                    <li><a href="#summary-tracing-pathname-2-homealexliteraturebarfoo"><span
                                class="toc-section-number">6.5</span> Summary Tracing Pathname 2:
                            <code>/home/alex/literature/barfoo</code></a></li>
                    <li><a href="#every-inode-has-a-link-count-a-count-of-names"><span
                                class="toc-section-number">6.6</span> Every inode has a link count: a count of names</a>
                    </li>
                    <li><a href="#permissions-on-data-vs.permissions-on-directories"><span
                                class="toc-section-number">6.7</span> Permissions on data vs. permissions on
                            directories</a></li>
                </ul>
            </li>
            <li><a href="#exercise-questions-on-hard-links-and-directories"><span class="toc-section-number">7</span>
                    Exercise Questions on Hard Links and Directories</a></li>
        </ul>
    </div>
    <div id="file-systems-contain-names-of-directories-and-files" class="section level1">
        <h1><span class="header-section-number">1</span> File systems contain names of directories and files<span
                class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>Unix/Linux has hierarchical file systems consisting of directories, sub-directories, and data files. Each
            thing has a name in the file system tree.</p>
        <div id="files-are-a-list-of-bytes" class="section level2">
            <h2><span class="header-section-number">1.1</span> Files are a list of bytes<span class="uptoTOC"><a
                        href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>In Unix, a <strong>file</strong> is a sequence of bytes without structure. Any necessary structure (e.g.
                for a database) is added by the programs that manipulate the data in the file. Linux itself doesn’t know
                about the internal structure of a database file – all it does is return bytes.</p>
            <blockquote>
                <p>Most Unix books say “everything is a file”, and they loosely use the word “file” to refer to anything
                    in the file system, including directories, symbolic links, devices, etc. The manual page for the
                    <code>find</code> command says that it can <code>search for files</code>, but it really means that
                    it can search for any kind of thing, not just strictly a “file”.</p>
            </blockquote>
        </div>
        <div id="even-hardware-devices-have-file-names" class="section level2">
            <h2><span class="header-section-number">1.2</span> Even hardware devices have file names<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Unix tries its best to treat every device attached to it as if it were a list of bytes. Therefore,
                everything, including network cards, hard drives, partitions, keyboards, printers, and plain files are
                treated as file-like objects and each has a name in the file system:</p>
            <ul>
                <li>Your computer memory is <code>/dev/mem</code>.</li>
                <li>Your first hard disk is <code>/dev/sda</code>.</li>
                <li>A terminal (keyboard and screen) is <code>/dev/tty1</code>.</li>
                <li>Etc.</li>
            </ul>
            <!-- -->
            <pre><code>$ ls -li /dev/mem /dev/sda /dev/tty1
5792 crw-r----- 1 root kmem 1, 1 Oct 13 02:30 /dev/mem
 888 brw-rw---- 1 root disk 8, 0 Oct 13 02:30 /dev/sda
5808 crw-rw---- 1 root tty  4, 1 Oct 13 02:31 /dev/tty1</code></pre>
            <p>Most input and output devices and directories are treated as files in Linux. If you have sufficient
                permissions, you can directly read all these devices using their file system names. Recent versions of
                Unix have evolved directories into non-readable (non-file) objects.</p>
        </div>
    </div>
    <div id="things-are-stored-in-index-nodes-inodes" class="section level1">
        <h1><span class="header-section-number">2</span> Things are stored in Index Nodes = Inodes<span
                class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>As with most things computer-related, things in the file system are not stored on disk by name, they are
            stored using a numbered data structure called an index number or <strong>inode</strong>.</p>
        <p>Everything in a Unix file system has a unique inode number that manages the storage and attributes for that
            thing: every file, directory, special file, etc. Files and directories are both managed with inodes.</p>
        <div id="directories-map-names-to-inode-numbers" class="section level2">
            <h2><span class="header-section-number">2.1</span> Directories map names to inode numbers<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Directories map file system names to inode numbers for you. Each inode is identified by a unique inode
                number that can be shown using the <code>-i</code> option to the <code>ls</code> command:</p>
            <pre><code>$ ls -l -i /usr/bin/perl*
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl5.14.2
266331 -rwxr-xr-x 2 root root 45183 Mar 18  2013 /usr/bin/perlbug
266328 -rwxr-xr-x 1 root root   224 Mar 18  2013 /usr/bin/perldoc
266329 -rwxr-xr-x 1 root root   125 Mar 18  2013 /usr/bin/perldoc.stub
266330 -rwxr-xr-x 1 root root 12318 Mar 18  2013 /usr/bin/perlivp
266331 -rwxr-xr-x 2 root root 45183 Mar 18  2013 /usr/bin/perlthanks</code></pre>
            <p>The program <code>/usr/bin/perl</code>, above, is not stored on disk in the same place as its name
                <code>perl</code>; it is stored in an inode somewhere else, under inode number <code>266327</code>.</p>
            <p>Unix <strong>directories</strong> are what map file system names (e.g. <code>perl</code>) to inode
                numbers (e.g. <code>266327</code>) that contain the actual data.</p>
            <p>In the example above, you can see that file name <code>/usr/bin/perl</code> really leads to inode number
                <code>266327</code> and that another name <code>perl5.14.2</code> leads to the same inode number. The
                names are separate from the things they name.</p>
            <p>When you access the <code>perl</code> program by name, the system finds the <code>perl</code> name in a
                directory, paired with the inode number <code>266327</code> that holds the actual data, and then the
                system has to go elsewhere on disk to that inode number <code>266327</code> to access the data for the
                <code>perl</code> program.</p>
            <p>File and directory data is actually stored under inode numbers, not under names. Directories map the
                names to the inode numbers for you.</p>
        </div>
        <div id="one-inode-many-names" class="section level2">
            <h2><span class="header-section-number">2.2</span> One inode, many names<span class="uptoTOC"><a
                        href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>As you can see above, a name <code>perl</code> in a directory leads to a single inode number
                <code>266327</code>, but the inode <code>266327</code> may have several names that lead to it, e.g. both
                <code>perl</code> and <code>perl5.14.2</code>.</p>
            <p>Each file name is mapped to only one single inode number, but one file inode number may have many names
                that map to it.</p>
        </div>
        <div id="inodes-contain-pointers-to-disk-blocks" class="section level2">
            <h2><span class="header-section-number">2.3</span> Inodes contain pointers to disk blocks<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>A Unix inode manages the disk storage space for a file or a directory. The inode contains a list of
                pointers to the disk blocks that belong to that file or directory.</p>
            <p>The disk blocks store the data for the inode. The larger the file or directory, the more disk block
                pointers it needs in the inode.</p>
        </div>
        <div id="inodes-contain-attributes-owners-permissions-times-etc." class="section level2">
            <h2><span class="header-section-number">2.4</span> Inodes contain attributes (owners, permissions, times,
                etc.)<span class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Also stored in the inode are the attributes of the file or directory: permissions, owner, group, size,
                access/modify times, etc.</p>
            <p>The attributes of a file are stored in the inode for the file. They attributes not stored with the name
                of the file, which is up in some directory.</p>
            <p>The attributes of a directory are also stored in the inode for the directory. The attributes of the
                things named <em>in</em> the directory – names of files or sub-directories – are <em>not</em> stored in
                the directory; they are stored in the individual inodes of those things.</p>
            <p>The attributes of a directory inode apply only to that directory itself, not to the things named
                <em>in</em> the directory, which have their own inodes.</p>
            <p>The name of the file or directory is <em>not</em> stored in its own inode. Inodes have only numbers,
                attributes, and disk blocks – an inode does not contain its own name. The names are kept separately, in
                directories.</p>
        </div>
        <div id="inodes-are-unique-inside-a-file-system" class="section level2">
            <h2><span class="header-section-number">2.5</span> Inodes are unique inside a file system<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Inode numbers are specific to a <strong>file system</strong> inside a <strong>disk partition</strong>.
                Each file system has its own set of inode numbers.</p>
            <p>Numbering is done separately for each file system, so different disk partitions may have file system
                objects with the same inode numbers.</p>
        </div>
        <div id="inodes-are-a-fixed-resource" class="section level2">
            <h2><span class="header-section-number">2.6</span> Inodes are a fixed resource<span class="uptoTOC"><a
                        href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Every Linux file system is created new with a large set of available inodes. You can list the free inodes
                using <code class="pre">df -i</code>. Some types of Unix file systems can never make more inodes, even
                if there is lots of disk space available; when all the inodes are used up, the file system can create no
                more files until some files are deleted to free some inodes.</p>
        </div>
    </div>
    <div id="file-system-diagrams-are-wrong" class="section level1">
        <h1><span class="header-section-number">3</span> File System Diagrams are Wrong<span class="uptoTOC"><a
                    href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>Most diagrams showing file systems and links in Unix texts are wrong and range from confusing to seriously
            misleading. Here’s the truth, complete with an ASCII-art file system diagram below.</p>
        <p>The names for inodes (names for files, directories, devices, etc.) are stored on disk in directories. Only
            the <em>names</em> and the associated <em>inode numbers</em> are stored in the directory; the actual
            <em>disk space</em> for whatever data is being named is stored in the numbered inode, not in the directory.
            The names and numbers are kept in the directory; the names are <em>not</em> kept with the data, which is in
            the inode.</p>
        <p>In the directory, beside each name, is the index number (inode number) indicating where to find the disk
            space used to actually store the thing being named. You can see this name-inode pairing using
            <code>ls -i</code>:</p>
        <pre><code>$ ls -i /usr/bin/perl*
266327 /usr/bin/perl        266329 /usr/bin/perldoc.stub
266327 /usr/bin/perl5.14.2  266330 /usr/bin/perlivp
266331 /usr/bin/perlbug     266331 /usr/bin/perlthanks
266328 /usr/bin/perldoc</code></pre>
        <p>The crucial thing to know is that the names and the actual storage for the things being named are in
            <em>separate places</em>. Most texts make the error of writing Unix file system diagrams that put the names
            right <em>on</em> the things that are being named. That is misleading and the cause of many
            misunderstandings about Unix files and directories.</p>
        <p>Names exist one level <em>above</em> (separate from) the items that they name:</p>
        <pre><code>WRONG - names on things      RIGHT - names above things
=======================      ==========================
                                                      
    R O O T            ---&gt;         [etc,bin,home]   &lt;-- ROOT directory
   /   |   \                         /    |      \
etc   bin   home       ---&gt;  [passwd]  [ls,rm]  [abcd0001]
 |   /   \    \                 |      /    \       |
 |  ls   rm  abcd0001  ---&gt;     |  &lt;data&gt;  &lt;data&gt;  [.bashrc]
 |               |              |                   |
passwd       .bashrc   ---&gt;  &lt;data&gt;                &lt;data&gt;</code></pre>
        <p>Directories are lists of names and inode numbers, as shown by the square-bracketed lists in the diagram on
            the right, above. (The actual inode numbers are omitted from this small diagram.)</p>
        <p>The name of each thing (file, directory, special file, etc.) is kept in a directory, separate from the
            storage space for the thing it names. This allows inodes to have multiple names and to have names in
            multiple directories; all the names can refer to the same storage space by simply using the same inode
            number.</p>
        <p>In the correct diagram on the right, the directories are lists of names in square brackets. Directories give
            names to the objects below them in the tree. The top directory on the right is the ROOT directory inode,
            containing the list of names under it: <code>etc</code>, <code>bin</code>, <code>home</code>, and others.
        </p>
        <p>The line leading downwards from the name <code>bin</code> in the ROOT directory indicates that the name
            <code>bin</code> is paired with an inode number that is another directory inode containing the list of names
            in the <code>bin</code> directory, including names <code>ls</code> and <code>rm</code> and others. The line
            leading down from <code>ls</code> in the <code>bin</code> directory inode leads to the data inode for the
            file <code>/bin/ls</code>. There is no name kept with the data inode – the name is up in the directory above
            it.</p>
        <p>The ROOT directory inode has no name because there is no directory above it to give it one! Every other
            directory except ROOT has a name because there is a directory inode above it that contains its name.</p>
    </div>
    <div id="directories-hold-only-names-and-inode-numbers" class="section level1">
        <h1><span class="header-section-number">4</span> Directories hold only names and inode numbers<span
                class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>To make a hierarchical file system, file system names are stored in directories.</p>
        <p>Each Unix directory is itself an inode. Like all inodes, directory inodes contain pointers to disk blocks and
            attribute information about the inode (permissions, owner, etc.), but what is stored in the disk blocks of a
            directory inode is not file data but directory data. That directly data is simply a list of names and inode
            numbers.</p>
        <p>The directory inode contains attribute information about the <em>directory</em>, itself, not about the things
            named <em>in</em> the directory. (Use <code class="pre">ls -ld</code> to see the attributes of the directory
            inode itself.)</p>
        <p>On Unix, for each thing in the file system, only the name and the inode number of the thing is kept in the
            directory. No data or attributes about the thing are kept in the directory, only the name of the thing and
            its inode number.</p>
        <p>The <em>name</em> of a file is kept in a directory, paired with its inode number. The file’s actual
            attributes and pointers to disk blocks are kept elsewhere, in the inode for the file.</p>
        <p>This means that names are not kept in the same inodes with the things that they name.</p>
        <p>Directories are what give names to inodes on Unix. Directories can be thought of as “files containing lists
            of names and inode numbers”. Files have disk blocks containing file data; directories also have disk blocks;
            but, the blocks contain lists of names and inode numbers.</p>
        <p>If a directory is damaged in Unix, only the names are lost, not any of the file data blocks or the file
            attributes.</p>
        <div id="attributes-are-stored-with-the-inode-not-the-name" class="section level2">
            <h2><span class="header-section-number">4.1</span> Attributes are stored with the inode, not the name<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>A Unix directory is only a list of pairs of names and associated inode numbers. The attribute information
                about an item named <em>in</em> a directory – the type, permissions, owner, etc. of the thing – is kept
                with the inode associated with the thing, not in the directory.</p>
            <p>Reading a Unix directory tells you only some names and inode numbers; you know nothing about the types,
                sizes, owners, or modify times of those inodes unless you actually go out to each separate inode on disk
                and access it to read its attributes. Without actually accessing the inode, you can’t know the
                attributes of the inode; you can’t even know if the inode is a file inode or a directory inode. (Some
                modern Unix file systems also cache a second copy of the inode type in the directory to speed up common
                file system browsing operations.)</p>
            <p>To find out attribute information of some file system object, that information is stored in the inode of
                the object, not in the directory. You must first use the inode number associated with the object to find
                the inode of the item and look at the item’s attributes. This is why <code>ls</code> or <code
                    class="pre">ls -i</code> are much faster than <code class="pre">ls -l</code> on a huge directory:
            </p>
            <ol style="list-style-type: lower-alpha">
                <li><code>ls</code> or <code class="pre">ls -i</code> only need to read the names and inode numbers from
                    the directory – no additional inode access is needed because no other attributes are being queried.
                    Reading the one directory inode is sufficient.</li>
                <li><code class="pre">ls -l</code> has to display attribute information for every object named in the
                    directory, so it has to do a separate inode lookup to find out the inode attribute information for
                    every inode in the directory. A directory with 1000 names in it requires 1000 separate inode lookups
                    to fetch the attributes!</li>
            </ol>
            <p>No attribute information about the things named in the directory is kept in the directory (except on
                those modern file systems where caching of inode type is enabled). The directory only contains pairs of
                names and inode numbers.</p>
            <p>To find a thing by name, the system goes to a directory inode, looks up the name in the disk space
                allocated to that directory, finds the inode number associated with the name, then goes out to the disk
                a second time and finds that inode on the disk. If that inode is another directory, the process repeats
                from left-to-right along the pathname until the inode of the last pathname component (on the far right
                in the pathname) is found. Then the disk block pointers of that last inode can be used to find the data
                contents of the last pathname component.</p>
        </div>
        <div id="damaged-directories-create-orphans" class="section level2">
            <h2><span class="header-section-number">4.2</span> Damaged directories create orphans<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>The name and inode number pairing in a Unix directory is the only connection between a name and the thing
                it names on disk. The name is kept separate from the data belonging to the thing it names (the actual
                inode on disk).</p>
            <p>If a disk error damages a directory inode or the directory disk blocks, file data is not usually lost;
                since, the actual data for the things named in the directory are stored in inodes separate from the
                directory itself.</p>
            <p>If a directory is damaged, only the names of the things are lost and the inodes become “orphan” inodes
                without names. The storage used for the things themselves is elsewhere on disk and may be undamaged. You
                can run a file system recovery program such as <code>fsck</code> to recover the data (but not the
                names).</p>
            <p>The name of an item (file, directory, etc.) and its inode number are the only things kept in a directory.
                The directory storage for that name and number is managed by its own inode that is separate from the
                inode of each thing in the directory. The name and number are stored in the directory inode; the data
                for the item named is stored in its own inode somewhere else.</p>
        </div>
    </div>
    <div id="multiple-names-hard-links" class="section level1">
        <h1><span class="header-section-number">5</span> Multiple names – hard links<span class="uptoTOC"><a
                    href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>Because (1) data in a file is managed by an inode with a unique number, (2) the name of the file is not kept
            in that inode, and (3) directories pair names with inode numbers, a Unix file (inode) can be given multiple
            names by having multiple name-and-inode pairs in one or more directories.</p>
        <p>Inode <code>123</code> may be paired with the name <code>cat</code> in one directory and the same
            <code>123</code> may be paired with the name <code>dog</code> in the same or a different directory. Either
            name leads to the same <code>123</code> file inode and the same data and attributes. Though there appear to
            be two different files <code>cat</code> and <code>dog</code> in the directory, the only thing different
            between the two is the name – both names lead to the same inode and therefore to the same data and
            attributes (permissions, owner, etc.).</p>
        <blockquote>
            <p>You can use <code class="pre">ls -i</code> to see the inode numbers paired with each name, and the
                <code>find</code> command has a useful <code>-inum</code> expression operator.</p>
        </blockquote>
        <div id="link-counts-count-names-ln-creates-rm-removes-only-a-name" class="section level2">
            <h2><span class="header-section-number">5.1</span> Link counts count names; <code>ln</code> creates,
                <code>rm</code> removes only a name<span class="uptoTOC"><a href="#TOC">Index<img
                            src="common/toparrow.gif" width="44" height="17" alt="up to index" /></a></span></h2>
            <p>Multiple names for the same inode are called “hard links”. The system keeps a “link count” in each inode
                that counts the number of names each inode has been given. The <code>ln</code> command can create a new
                name (a new hard link) in a directory for an existing file inode, increasing the file’s inode link
                count. The <code>rm</code> command removes a name (a hard link) from a directory, decreasing the file’s
                inode link count.</p>
            <p>When the link count for an inode goes to zero, the inode has no names and the inode is freed and recycled
                and all the storage and data used by the item is released.</p>
            <p>The <code>rm</code> command does not remove <em>files</em>; it removes <em>names</em> for files. When all
                the names for a file inode are removed, the system removes the inode itself and releases all the disk
                space.</p>
            <p>As long as an inode has at least one name is some directory (a non-zero link count), it cannot be freed
                up and released.</p>
        </div>
    </div>
    <div id="tracing-inodes-in-pathnames-ascii-art" class="section level1">
        <h1><span class="header-section-number">6</span> Tracing Inodes in Pathnames – ASCII Art<span class="uptoTOC"><a
                    href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <p>Below is an ASCII Art diagram of some directories and a hard-linked file with two names.</p>
        <div id="slashes-separate-names-in-pathnames" class="section level2">
            <h2><span class="header-section-number">6.1</span> Slashes separate names in pathnames<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>When you look at a Unix pathname, remember that that the slashes separate the names of the pathname
                components. All the components to the left of the rightmost slash must be directories, including the
                “empty” ROOT directory name to the left of the leftmost slash. For example:</p>
            <pre><code>/home/alex/foobar</code></pre>
            <p>In the above example, there are three slashes and therefore four pathname components:</p>
            <ol style="list-style-type: decimal">
                <li>The nameless ROOT directory is the start of this absolute pathname.</li>
                <li>Inside the above ROOT directory is the name of the <code>home</code> directory.</li>
                <li>Inside the above <code>home</code> directory is the name of the <code>alex</code> directory.</li>
                <li>Inside the above <code>alex</code> directory is the name of the <code>foobar</code> file.</li>
            </ol>
            <blockquote>
                <p>The “empty” name in front of the first slash is the name of the ROOT directory. The ROOT directory
                    doesn’t have a name. (Some books get around this by calling the ROOT directory “slash” or
                    <code>/</code>. That is wrong. ROOT doesn’t have a name – slashes <em>separate</em> names.)</p>
            </blockquote>
            <p>The last (rightmost) component of a pathname can be a file or a directory (or any other thing, such as a
                symbolic link); for this example, let’s assume <code>foobar</code> is a name for a file inode.</p>
        </div>
        <div id="names-reside-above-the-things-they-name" class="section level2">
            <h2><span class="header-section-number">6.2</span> Names reside above the things they name<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Below is a file system diagram written correctly, with the names for things shown in the directory one
                level <em>above</em> the things to which the names actually refer. Each box represents an inode; the
                inode numbers for the box are given beside the box, on the left.</p>
            <p>Inside the directory inodes you can see the pairing of names and inode numbers. (These inode numbers are
                made up – see your actual Unix system for some real inode numbers.)</p>
            <p>One of the inodes below, <code>#12</code>, is not a directory; it is an inode for a file and the inode
                contains the file data.</p>
            <p>The downward arrows in the diagram trace two paths (hard links) to the same <code>#12</code> file data,
                <code>/home/alex/foobar</code> and <code>/home/alex/literature/barfoo</code>.</p>
            <p>We will trace the inodes for two pathnames in the diagram below:</p>
            <ol style="list-style-type: decimal">
                <li><code>/home/alex/foobar</code></li>
                <li><code>/home/alex/literature/barfoo</code></li>
            </ol>
            <p>Follow the downward-pointing arrows:</p>
            <pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+--v--------------------------------------+
                  |  The inode #2 above is the ROOT directory. It has the
                  |  name &quot;home&quot; in it. The *directory* &quot;home&quot; is not
                  |  here; only the *name* is here. The ROOT directory
                  |  itself does not have a name, because there is no
                  V  directory above it to give it a name!
    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+--v------------------------------------------------+
                  |  The inode #5 above is the &quot;home&quot; directory. The name
                  |  &quot;home&quot; isn&#39;t here; it&#39;s up in the ROOT directory,
                  |  above. This directory has the name &quot;alex&quot; in it.
                  V
    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+--v-----------------------------v------------------+
                  |  The inode #31 above is     |
                  |  the &quot;alex&quot; directory. The  |
                  |  name &quot;alex&quot; isn&#39;t here;    |
                  |  it&#39;s up in the &quot;home&quot;      |
                  |  directory, above.  This    |
                  |  directory has the names    |
                  |  &quot;foobar&quot; and &quot;literature&quot;  |
                  |  in it.                     |
                  |                             V
    +----+-----+--|-------------------------------------------+
#7  |. 7 |.. 31|  |  barfoo 12 | morestuf 123 | junk 99 | ... |
    +----+-----+--|-------v-----------------------------------+
                  |       |  The inode #7 above is the &quot;literature&quot; directory.
                  |       |  The name &quot;literature&quot; isn&#39;t here; it&#39;s up
                  |       |  in the &quot;alex&quot; directory.  This directory has
                  |       |  the name &quot;barfoo&quot; in it.
                  |       |
                  V       V
                 *-----------*  This inode #12 on the left is a file inode.
                 | file data |  It contains pointers to the data blocks for the file.
             #12 | file data |  This file inode has two names, &quot;foobar&quot; and &quot;barfoo&quot;,
                 | file data |  but those names are not here.  Those two names are up
                 *-----------*  up in the two directories that point to this file, above.
                                Because this inode has two names, it has a link count of two.</code></pre>
            <p>The absolute pathname <code>/home/alex/foobar</code> starts at the nameless ROOT directory, inode
                <code>#2</code>. It travels through two more directory inodes and stops at file inode <code>#12</code>.
                Using all four inode numbers, <code>/home/alex/foobar</code> could be written as
                <code>#2-&gt;#5-&gt;#31-&gt;#12</code>.</p>
            <p>The absolute pathname <code>/home/alex/literature/barfoo</code> starts at the ROOT inode and travels
                through three more directory inodes. It stops at the same <code>#12</code> file inode as
                <code>/home/alex/foobar</code>. Using all five inode numbers, <code>/home/alex/literature/barfoo</code>
                could be written as <code>#2-&gt;#5-&gt;#31-&gt;#7-&gt;#12</code>.</p>
            <p>Thus, <code>/home/alex/foobar</code> and <code>/home/alex/literature/barfoo</code> are two absolute
                pathnames leading to the same inode <code>#12</code> file data. The names <code>foobar</code> and
                <code>barfoo</code> are two names for the same file and are called “hard links”. Because the file inode
                <code>#12</code> has two names, it has a “link count” of two.</p>
            <p>Let’s examine each of the two pathnames and their inodes in more detail.</p>
        </div>
        <div id="tracing-pathname-1-homealexfoobar" class="section level2">
            <h2><span class="header-section-number">6.3</span> Tracing Pathname 1: <code>/home/alex/foobar</code><span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <blockquote>
                <p>Remember: Directories are chunks of storage that pair names with inode numbers. That is all that is
                    in a directory: names and inode numbers.</p>
            </blockquote>
            <p>The box below represents the layout of names and inode numbers inside the actual disk space given to the
                nameless ROOT directory, inode <code>#2</code>:</p>
            <pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+-----------------------------------------+</code></pre>
            <p>If you look at the ROOT directory above, you will see that both the name <code>.</code> and the name
                <code>..</code> in this ROOT directory are paired with inode <code>#2</code>, the inode number of the
                ROOT directory itself.</p>
            <p>Following either name <code>.</code> or <code>..</code> will lead to inode <code>#2</code> and right back
                to this same ROOT inode. The ROOT directory is the only directory that is its own parent.</p>
            <p>The above ROOT directory has the name <code>home</code> in it, paired with inode <code>#5</code>. The
                actual disk <em>space</em> of the directory <code>home</code> is not here; only the <em>name</em>
                <code>home</code> is here, along with its own inode number <code>#5</code>. To read the actual contents
                of the <code>home</code> directory, find the disk space managed by inode <code>#5</code> somewhere else
                on disk and look there. (In fact, until we look up inode <code>#5</code> and find out that it is a
                directory inode, we have no way of even knowing that the name <code>home</code> is a name of a
                directory!)</p>
            <p>The above ROOT directory pairing of <code>home</code> with inode <code>#5</code> is what gives the
                <code>home</code> directory inode its name. The name <code>home</code> is separate from the disk space
                for <code>home</code>. The ROOT directory itself does not have a name; because, it has no parent
                directory to give it a name!</p>
            <p>Let us move to the storage space for the <code>home</code> directory at inode <code>#5</code>.</p>
            <p>The box below represents the layout of names and inode numbers inside the actual disk space given to the
                <code>home</code> directory, inode <code>#5</code>:</p>
            <pre><code>    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+---------------------------------------------------+</code></pre>
            <p>The name <code>home</code> for this inode <code>#5</code>isn’t found in this inode; the name
                <code>home</code> is given to inode <code>#5</code> up in the ROOT directory. Names are separate from
                the things they name.</p>
            <p>We see that the name <code>.</code> above leads back to this same <code>#5</code> inode, which is why
                <code>/home</code> and <code>/home/.</code> lead to the same <code>#5</code> inode.</p>
            <p>We see that the name <code>..</code> above leads up to the parent <code>#2</code> inode (the ROOT inode),
                which is why <code>/home/..</code> leads us to <code>/</code> the ROOT.</p>
            <p>The above <code>home</code> directory has the name <code>alex</code> in it, paired with inode
                <code>#31</code>. The actual disk <em>space</em> of the directory <code>alex</code> is not here; only
                the <em>name</em> <code>alex</code> is here, along with its own inode number <code>#31</code>. To read
                the actual contents of the <code>alex</code> directory, find the disk space manged by inode
                <code>#31</code> somewhere on disk and look there. (In fact, until we look up inode <code>#31</code> and
                find out that it is a directory inode, we have no way of even knowing that the name <code>alex</code> is
                a name of a directory!)</p>
            <p>The above <code>home</code> directory pairing of <code>alex</code> with inode <code>#31</code> is what
                gives the <code>alex</code> directory inode its name. The name <code>alex</code> is separate from the
                disk space for <code>alex</code>.</p>
            <p>Let us move to the storage space for the <code>alex</code> directory at inode <code>#31</code>.</p>
            <p>The box below represents the layout of names and inode numbers inside the actual disk space given to the
                <code>alex</code> directory, inode <code>#31</code>:</p>
            <pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+</code></pre>
            <p>The name <code>alex</code> for this inode isn’t in this inode; the name <code>alex</code> is given to
                inode <code>#31</code> up in the <code>home</code> directory. Names are separate from the things they
                name.</p>
            <p>We see that the name <code>.</code> above leads back to this same <code>#31</code> inode, which is why
                <code>/home/alex</code> and <code>/home/alex/.</code> lead to the same <code>#31</code> inode.</p>
            <p>We see that the name <code>..</code> above leads up to the parent <code>#5</code> inode (the
                <code>/home</code> inode), which is why <code>/home/alex/..</code> leads us to <code>/home</code>.</p>
            <p>The above <code>alex</code> directory has the name <code>foobar</code> in it, paired with inode
                <code>#12</code>. The actual disk <em>space</em> of the file <code>foobar</code> is not here; only the
                <em>name</em> <code>foobar</code> is here, along with its own inode number <code>#12</code>. To read the
                actual data of the file <code>foobar</code>, find the disk space managed by inode <code>#12</code>
                somewhere on disk and look there. (In fact, until we look up inode <code>#12</code> and find out that it
                is a plain file inode, we no way of even knowing that the name <code>foobar</code> is a name of a plain
                file!)</p>
            <p>The above <code>alex</code> directory pairing of <code>foobar</code> with inode <code>#12</code> is what
                gives the <code>foobar</code> file inode one of its two names. The name <code>foobar</code> is separate
                from the disk space for <code>foobar</code>.</p>
            <p>Let us move to the storage space for the <code>foobar</code> file at inode <code>#12</code>.</p>
            <p>The box below represents the actual disk space given to the <code>foobar</code> file, inode
                <code>#12</code>:</p>
            <pre><code>    *-----------*
#12 | file data |
    *-----------*</code></pre>
            <p>The name <code>foobar</code> for this inode isn’t in this inode; the name <code>foobar</code> is up in
                the <code>alex</code> directory. Names are separate from the things they name.</p>
            <blockquote>
                <p>This <code>foobar</code> inode is a file inode, not a directory inode, and the attributes of this
                    inode will indicate that. All the attributes of an inode – type, permissions, owner, group, modify
                    date, etc. – are stored in the inode itself. The only thing <em>not</em> stored in the inode is the
                    <em>name</em> of the inode, which is always stored in the directory above the inode (the parent
                    directory of the inode).</p>
            </blockquote>
            <p>The inode for a file contains pointers to disk blocks that contain file data, not directory data. There
                are no special directory names <code>.</code> and <code>..</code> in files. There are no names here at
                all; the disk block pointers in this inode point to just file data (whatever is in the file).</p>
            <p>This completes the inode trace for <code>/home/alex/foobar</code>: <code>#2-&gt;#5-&gt;#31-&gt;#12</code>
            </p>
            <p>But <code>foobar</code> is just one of the names for inode <code>#12</code>; it has another name, too.
            </p>
        </div>
        <div id="tracing-pathname-2-homealexliteraturebarfoo" class="section level2">
            <h2><span class="header-section-number">6.4</span> Tracing Pathname 2:
                <code>/home/alex/literature/barfoo</code><span class="uptoTOC"><a href="#TOC">Index<img
                            src="common/toparrow.gif" width="44" height="17" alt="up to index" /></a></span></h2>
            <blockquote>
                <p>Remember: Directories are chunks of storage that pair names with inode numbers. That is all that is
                    in a directory: names and inode numbers.</p>
            </blockquote>
            <p>Let’s now trace the inode path for the name <code>/home/alex/literature/barfoo</code>. This pathname is a
                “hard link” to <code>/home/alex/foobar</code>; both the <code>foobar</code> and <code>barfoo</code>
                names point to the same inode number. Let’s see how this is possible.</p>
            <p>The trace from ROOT through <code>/home/alex</code> is the same as before. Things change in our second
                trace because of <code>/home/alex/literature</code>.</p>
            <p>If we look at the <code>alex</code> directory inode <code>#31</code> again, we see that the name
                <code>literature</code> is paired with inode <code>#7</code>:</p>
            <pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+</code></pre>
            <p>The above <code>alex</code> directory has the name <code>literature</code> in it, paired with inode
                <code>#7</code>. The actual disk <em>space</em> of the directory <code>literature</code> is not here;
                only the <em>name</em> <code>literature</code> is here, along with its own inode number <code>#7</code>.
                To read the actual contents of the directory <code>literature</code>, find the disk space managed by
                inode <code>#7</code> somewhere else on disk and look there. (In fact, until we look up inode
                <code>#7</code> and find out that it is a directory inode, we no way of even knowing that the name
                <code>literature</code> is a name of a directory!)</p>
            <p>Let us move to the storage space for the <code>literature</code> directory at inode <code>#7</code>.</p>
            <p>The box below represents the layout of names and inode numbers inside the actual disk space given to the
                <code>literature</code> directory, inode <code>#7</code>:</p>
            <pre><code>    +----+-----+---------------------------------------------+
#7  |. 7 |.. 31|    barfoo 12 | morestuf 123 | junk 99 | ... |
    +----+-----+---------------------------------------------+</code></pre>
            <p>The name <code>literature</code> for this inode isn’t in this inode; the name <code>literature</code> is
                given to inode <code>#7</code> up in the <code>alex</code> directory. Names are separate from the things
                they name.</p>
            <p>We see that the name <code>.</code> above leads back to this same <code>#7</code> inode, which is why
                <code>/home/alex/literature</code> and <code>/home/alex/literature/.</code> lead to the same
                <code>#7</code> inode.</p>
            <p>We see that the name <code>..</code> above leads up to the parent <code>#31</code> inode (the
                <code>/home/alex</code> inode), which is why <code>/home/alex/literature/..</code> leads us to
                <code>/home/alex</code>.</p>
            <p>The above <code>literature</code> directory has the name <code>barfoo</code> in it, paired with inode
                <code>#12</code>. The actual disk <em>space</em> of the file <code>barfoo</code> is not here; only the
                <em>name</em> <code>barfoo</code> is here, along with its own inode number <code>#12</code>. To read the
                actual data of the file <code>barfoo</code>, find the disk space managed by inode <code>#12</code>
                somewhere on disk and look there. (In fact, until we look up inode <code>#12</code> and find out that it
                is a plain file inode, we no way of even knowing that the name <code>barfoo</code> is a name of a plain
                file!)</p>
            <p>The above <code>literature</code> directory pairing of <code>barfoo</code> with inode <code>#12</code> is
                what gives the <code>barfoo</code> file inode the other one of its two names. The name
                <code>barfoo</code> is separate from the disk space for <code>barfoo</code>.</p>
            <p>You will recall that we have seen inode <code>#12</code> in the previous trace. Above, in the
                <code>alex</code> directory (inode <code>#31</code>), inode <code>#12</code> was also paired with the
                name <code>foobar</code>. In the <code>literature</code> directory (inode <code>#7</code>), inode
                <code>#12</code> is paired with the name <code>barfoo</code>. Inode <code>#12</code> therefore has two
                different names; both names <code>foobar</code> and <code>barfoo</code> are both hard links to the same
                inode <code>#12</code>, and the <code>ls</code> command can prove this:</p>
            <pre><code>$ ls -i /home/alex/foobar /home/alex/literature/barfoo
12 /home/alex/foobar   12 /home/alex/literature/barfoo</code></pre>
            <p>Having two names means the “link count” of inode <code>#12</code> is set to “<code>2</code>”. Both names
                lead to the same <code>#12</code> inode and thus to the same data and same attributes. This is
                <em>one</em> single file with <em>two</em> names. A change to the file data using the name
                <code>foobar</code> changes the data in inode <code>#12</code>. That changes file data for the name
                <code>barfoo</code> too; because, <code>foobar</code> and <code>barfoo</code> are two names for the same
                <code>#12</code> inode storage – they are two names that point to the same storage inode.</p>
            <p>All the inode attributes – everything about data inode <code>#12</code> except its name – is kept with
                the inode. The only thing different in a long listing of <code>foobar</code> and <code>barfoo</code>
                will be the names; everything else (file type, permissions, owner, group, link count, size, modification
                times, etc.) is part of inode <code>#12</code> and must therefore be identical for the two names.
                Neither name is more “original” than the other; both names have equal status. To release the
                <code>#12</code> inode storage, you have to delete both names so that the link count of inode
                <code>#12</code> drops to zero.</p>
        </div>
        <div id="summary-tracing-pathname-2-homealexliteraturebarfoo" class="section level2">
            <h2><span class="header-section-number">6.5</span> Summary Tracing Pathname 2:
                <code>/home/alex/literature/barfoo</code><span class="uptoTOC"><a href="#TOC">Index<img
                            src="common/toparrow.gif" width="44" height="17" alt="up to index" /></a></span></h2>
            <p>Let’s summarize the inodes used in this pathname:</p>
            <pre><code>/home/alex/literature/barfoo</code></pre>
            <p>Start on the left and walk the tree of names and inodes left to right. To be a valid Unix path,
                everything to the left of the rightmost slash must be a directory. (Thus, ROOT, <code>home</code>,
                <code>alex</code>, and <code>literature</code> must be directories, if this is a valid pathname.)</p>
            <p>Start with the nameless ROOT directory in front of the first slash (ROOT doesn’t have a name, since it
                does not appear in any parent directory) and look for the first pathname component (<code>home</code>)
                inside that ROOT directory (inside inode <code>#2</code>).</p>
            <p>Let’s trace the pathname:</p>
            <p>Look in the ROOT directory (located in inode <code>#2</code>) for the name of the first pathname
                component: <code>home</code>. We find the name <code>home</code> inside the ROOT directory, paired with
                inode <code>#5</code>. Go back out to the disk to find inode <code>#5</code> that is the actual
                <code>home</code> directory.</p>
            <blockquote>
                <p>Note how the names are separate from the things they name. The actual directory inode <code>#5</code>
                    of the <code>home</code> directory is not the same as the inode <code>#2</code> of the ROOT
                    directory that contains the directory name <code>home</code>. The name is stored in a different
                    place (<code>#2</code>) than the thing it names (<code>#5</code>).</p>
            </blockquote>
            <p>In inode <code>#5</code>, the directory inode that has the name <code>home</code>, look for the name
                <code>alex</code>. We find <code>alex</code> paired with inode <code>#31</code>. Go back out to the disk
                to find inode <code>#31</code> that is the actual <code>alex</code> directory inode. Again, the name
                <code>alex</code> is contained in directory inode <code>#5</code> (<code>home</code>) and that name is
                stored separately from inode <code>#31</code> that is the actual <code>alex</code> directory itself.</p>
            <p>In inode <code>#31</code>, the directory inode that has the name <code>alex</code>, look for the name
                <code>literature</code>. We find <code>literature</code> paired with inode <code>#7</code>. Go back out
                to the disk to find inode <code>#7</code> that is the actual <code>literature</code> directory inode.
                Again, the name <code>literature</code> is contained in directory inode <code>#31</code>
                (<code>alex</code>) and that name is stored separately from the inode <code>#7</code> that is the actual
                <code>literature</code> directory itself.</p>
            <p>In inode <code>#7</code>, the directory inode that has the name <code>literature</code>, look for the
                name <code>barfoo</code>. We find <code>barfoo</code> paired with inode <code>#12</code>. Go back out to
                the disk to find inode <code>#12</code> that is the actual data of the file <code>barfoo</code>. Again,
                the name <code>barfoo</code> is contained in directory inode <code>#7</code> (<code>literature</code>)
                and that name is stored separately from the inode <code>#12</code> that is the actual data of the file.
                The name of a file is not part of the inode that makes up the actual file data.</p>
            <p>We have found the inode that is the file data: inode <code>#12</code>. The name of this file,
                <code>barfoo</code>, is stored up in inode <code>#7</code> that is the <code>literature</code>
                directory. The name is separate from the data it names.</p>
        </div>
        <div id="every-inode-has-a-link-count-a-count-of-names" class="section level2">
            <h2><span class="header-section-number">6.6</span> Every inode has a link count: a count of names<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Every <strong>directory inode</strong> contains a name <code>..</code> (dot dot) paired with the number
                of the inode that is the unique parent directory of the inode. That unique parent directory is the only
                one containing the name of this inode. Because a directory can have only one parent, hard links are not
                permitted for directories. (The name <code>..</code> can only link to one parent directory.)</p>
            <p>Directory inode <code>#5</code> above contains the name <code>..</code> paired with inode <code>#2</code>
                (the ROOT directory), and it is in that <code>#2</code> inode directory that we see that inode
                <code>#5</code> is paired with the name <code>home</code>. The parent directory of inode <code>#5</code>
                is the directory that contains the name <code>home</code>.</p>
            <p>Unlike directory inodes, <strong>file inodes</strong> contain no record of which parent directories give
                it its names. The only thing that is recorded in the file inode is the number of names the inode has:
                the link count. File inode <code>#12</code> has two names, so it has a link count of two. The inode has
                no information about in which directories the two names are located.</p>
            <p>There is no easy way to know which directories give a file inode its one or more names. In a file inode,
                there is no name <code>..</code> to point to a parent directory, because a file inode might have
                hundreds or thousands of parent directories (thousands of names).</p>
            <p>If you have a file inode with multiple names (a link count larger than one) and you want to find the
                other names for the inode, you have to do a brute-force search in every directory on the file system to
                see which directories might have names paired with this inode number.</p>
            <p>Usually, the multiple names for an inode are in the same directory or in directories that are closely
                related to each other (parent directories, sub-directories, or sibling directories), but that isn’t
                always the case. In the worst case, finding all the names for a file inode may require searching for
                that inode number in <em>every</em> directory in the whole file system, something that could take hours
                on a very large file system.</p>
            <p>A file is deleted from disk only when its link count goes to zero, i.e. when all the names for the inode
                are removed. Then the disk blocks for the inode are returned to the system for use by other files, and
                the inode (with a zero link count) is returned to the pool of free and available inodes.</p>
        </div>
        <div id="permissions-on-data-vs.permissions-on-directories" class="section level2">
            <h2><span class="header-section-number">6.7</span> Permissions on data vs. permissions on directories<span
                    class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                            alt="up to index" /></a></span></h2>
            <p>Each Unix inode has a set of permissions that govern what a process can do to that inode. Since names are
                stored in directory inodes, separate from the inodes of things they name, a process may have permissions
                to change the name of a thing in a directory inode without having permissions to change the data in the
                inode that is the thing itself, or vice-versa.</p>
            <ul>
                <li>
                    <p>If a process has permission to change a directory inode, it can change the names of things in
                        that directory inode, including adding names (e.g. <code>ln</code>), removing names (e.g.
                        <code>rm</code>), or renaming names (e.g. <code>mv</code>). These are operations on directory
                        inodes.</p>
                </li>
                <li>
                    <p>If a process has permission to change a file inode, it can erase, append to, or change the
                        content of the file itself. The file inode is different from the inode containing the name of
                        the file.</p>
                </li>
            </ul>
            <p>Names are stored in directory inodes, separate from the things they name, so a process may have
                permissions to change the content of a file (the file inode) without having permissions to change the
                name of the file (the directory inode containing the name), or vice-versa.</p>
            <p>If file data inode <code>#12</code> above has appropriate permission attributes, a process could read or
                write the data in that file inode. It is the permission attributes on the inode <code>#12</code>
                containing the file <em>data</em> that govern what a process can do with the <em>data</em> in the file.
            </p>
            <p>The two names of the file, either <code>foobar</code> or <code>barfoo</code>, are stored up in directory
                inodes separate from the inode <code>#12</code>. The permissions on the inodes of those two parent
                directories containing the <em>names</em> of the file do not control whether a process can modify the
                inode containing the <em>data</em> of the file. It is the inode that contains the data
                (<code>#12</code>) that controls whether a process can read or write the data in that inode.</p>
            <p>Directory inodes have permissions that control whether a process is allowed to pass through the directory
                to access the things named in the directory. This is called <em>access</em> or <em>search</em>
                permission (<code>x</code>).</p>
            <p>If the any of the inodes of the directories containing the names leading down to the file at inode
                <code>#12</code> don’t give the process <em>search</em> permission, the process won’t be able to reach
                the file’s data inode that way and won’t be able to access the file’s data using those directories; but,
                perhaps some other directories may lead the process to the same inode <code>#12</code>, if the file has
                another name.</p>
            <p>To access and read the data in a file path such as:</p>
            <pre><code>/home/alex/literature/barfoo</code></pre>
            <p>you need appropriate <em>search</em> permissions on the ROOT directory inode, the <code>home</code>
                directory inode, the <code>alex</code> directory inode, the <code>literature</code> directory inode, and
                finally <em>read</em> permissions on the <code>barfoo</code> file data inode <code>#12</code>.</p>
            <p>It is the file data inode <code>#12</code> permissions that determine whether or not you can read or
                change the <em>data</em> of the file. Reading or changing the data in the file requires permissions on
                the inode <code>#12</code> that contains the data blocks of the file itself.</p>
            <p>It is the <code>literature</code> directory inode permissions (inode <code>#7</code>) that determine what
                you can do with the <em>name</em> <code>barfoo</code> of the file, because the <code>literature</code>
                directory (inode <code>#7</code>) is where the name <code>barfoo</code> is kept. Changing, linking to,
                or removing the name of a file operates on the inode of the <em>directory</em> in which the file name
                appears; altering the name has nothing to do with reading or changing the inode that contains the data
                blocks of the file itself.</p>
            <p>You can have no permissions on the inode that contains the data blocks of the file itself (it may even be
                owned by some other user) and still you may be able to rename or remove one of the names of the file
                from a directory on whose inode you do have permissions. The name(s) of a file is(are) stored in
                separate inodes from the data blocks of the file.</p>
            <p>Names are separate from the things that they name. The permissions of the names are also separate from
                the permissions of the data.</p>
            <ul>
                <li>
                    <p>Changing a <em>name</em> in a directory inode requires write and execute permissions on the
                        <em>directory</em> inode containing the name. No permissions are needed on the inode containing
                        the <em>data</em> of the thing being renamed. (Some recent Linux kernels have added security
                        that changes this.)</p>
                </li>
                <li>
                    <p>Changing the <em>content</em> of a file only requires write permissions on the data inode of the
                        <em>file</em> itself, not on the inode of any parent directory that holds one of the names of
                        the file.</p>
                </li>
            </ul>
            <p>Names are separate from the things they name, so two sets of permissions (two inodes) are always involved
                when a process tries to access a thing.</p>
        </div>
    </div>
    <div id="exercise-questions-on-hard-links-and-directories" class="section level1">
        <h1><span class="header-section-number">7</span> Exercise Questions on Hard Links and Directories<span
                class="uptoTOC"><a href="#TOC">Index<img src="common/toparrow.gif" width="44" height="17"
                        alt="up to index" /></a></span></h1>
        <ul>
            <li>
                <p>Normally when you do <code class="pre">ls -l dir</code> you see the permissions of the
                    <em>contents</em> of the directory, not the directory itself. What command and options are needed to
                    see the access permissions and link count of the directory inode itself, instead of the
                    <em>contents</em> of a directory? (See the Worksheets and also RTFM.)</p>
            </li>
            <li>
                <p>When you are inside a directory, what is the name you use to refer to the directory itself? (This
                    name works inside any directory.) What name always refers to the unique parent directory?</p>
            </li>
            <li>
                <p>How many links (names) does a brand new, empty directory have? Why isn’t it just one link, as it is
                    for a new file? (In other words, why does a new file have one link and a new directory have more
                    than that?)</p>
            </li>
            <li>
                <p>Why does creating a sub-directory in a directory cause the directory’s link (name) count to increase
                    by one for every sub-directory created? (Recall that a link count is a count of names.)</p>
            </li>
            <li>
                <p>Why doesn’t the link (name) count of the directory increase when you create files in the directory?
                </p>
            </li>
            <li>
                <p>Give the Unix command and its output that shows the inode number and owners of the following
                    directories. Only show the given directory; do not show any other directories:</p>
                <ol style="list-style-type: lower-alpha">
                    <li>your current directory</li>
                    <li>your parent directory</li>
                    <li>your HOME directory</li>
                    <li>the directory named <code>/home</code></li>
                    <li>the ROOT directory</li>
                    <li>the directory named <code>/root</code></li>
                </ol>
            </li>
        </ul>
        <p>Note: Show only one line of output for each single directory; do not show the contents of the directory. Use
            a command (and options) that will show only the directory itself, not its contents. (RTFM)</p>
        <!-- References -->
    </div>
    <div id="signature-block" class="slide section level1">
        <pre id="signature"><code><b>Author:</b> 
| Ian! D. Allen, BA, MMath  -  idallen@idallen.ca  -  Ottawa, Ontario, Canada
| Home Page: http://idallen.com/   Contact Improv: http://contactimprov.ca/
| College professor (Free/Libre GNU+Linux) at: http://teaching.idallen.com/
| Defend digital freedom:  http://eff.org/  and have fun:  http://fools.ca/</code></pre>
        <p><a href="450_file_system.txt">Plain Text</a> - plain text version of this page in <a
                href="http://johnmacfarlane.net/pandoc/">Pandoc Markdown</a> format
            <!-- vim:set softtabstop=4 expandtab: -->
        </p>
    </div>
    <div id="logo-block" class="slide section level1">
        <p>
            <a href="http://www.anybrowser.org/campaign/">
                <img style="border:0;width:88px;height:31px" src="common/anybrowser3.gif"
                    alt="Campaign for non-browser-specific HTML" /></a>
            &nbsp;
            <a href="http://validator.w3.org/check?uri=referer">
                <img style="border:0;width:88px;height:31px" src="http://www.w3.org/Icons/valid-xhtml10"
                    alt="Valid XHTML 1.0 Transitional" /></a>
            &nbsp;
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
                <img style="border:0;width:88px;height:31px" src="http://jigsaw.w3.org/css-validator/images/vcss"
                    alt="Valid CSS!" /></a>
            &nbsp;

            <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
                <img style="border:0;width:88px;height:31px" src="common/somerights.gif"
                    alt="Creative Commons by nc sa 3.0" /></a>
            &nbsp;
            <a href="http://www.catb.org/hacker-emblem/">
                <img style="border:0;width:35px;height:31px" src="common/glider-small.png"
                    alt="Hacker Ideals Emblem" /></a>

            &nbsp;
            <span style="vertical-align: 50%">
                Author <a href="http://idallen.com/">Ian! D. Allen</a>
            </span>
        </p>
    </div>
</body>

</html>